---
title: Python Lambda
date: 2019-10-02 00:00:00 Z
permalink: "/blog/pythonLambda"
categories:
- PythonExtra
tags:
- learning
- Installation
image: "/img/Python_logo.png"
author: Girish Godage
layout: posts
prevurl: "/blog/pythonXMLParser"
nexturl: "/blog/pythonLambda"
discussion_id: 2019-10-02-PythonLambda
---

<section class="Ptutorial27">
    <div class="item-page" itemscope="" itemtype="https://schema.org/Article">
        <meta itemprop="inLanguage" content="en-GB">
        <div class="page-header">
            <h2 itemprop="headline"> Python Lambda Functions with EXAMPLES </h2>
        </div>

        <div itemprop="articleBody">

            <h2><a id="1"></a>What is Lambda?</h2>
            <p>Lambdas, also known as anonymous functions, are small, restricted functions which do not need a name
                (i.e., an identifier). Lambda functions were first introduced to the field of mathematics by Alonzo
                Church in the 1930s. </p>
            <p>Today, many modern programming languages like Java, Python, C#, and C++ support lambda functions to add
                functionality to the languages. </p>
            <p>In this Lambda tutorial, you will learn: </p>
            <ul>
                <li><a href="#1">What is Lambda?</a> </li>
                <li><a href="#2">Lambdas in Python</a> </li>
                <li><a href="#3">Syntax and Examples</a> </li>
                <li><a href="#4">Using lambdas with Python built-ins</a> </li>
                <li><a href="#5">lambdas in filter()</a> </li>
                <li><a href="#6">lambdas in map()</a> </li>
                <li><a href="#7">lambdas in reduce()</a> </li>
                <li><a href="#8">Why (and why not) use lambda functions?</a> </li>
                <li><a href="#9">Lambdas vs. Regular functions</a> </li>
            </ul>
            <h2><a id="2"></a>Lambdas in Python</h2>
            <p>In Python, lambda expressions (or lambda forms) are utilized to construct anonymous functions. To do so,
                you will use the <strong>lambda </strong>keyword (just as you use <strong>def </strong>to define normal
                functions). </p>
            <p>Every anonymous function you define in Python will have 3 essential parts: </p>
            <ul>
                <li>The lambda keyword.</li>
                <li>The parameters (or bound variables), and</li>
                <li>The function body.</li>
            </ul>
            <p>A lambda function can have any number of parameters, but the function body can only contain
                <strong>one</strong> expression. </p>
            <p>Moreover, a lambda is written in a single line of code and can also be invoked immediately. You will see
                all this in action in the upcoming examples. </p>
            <h2><a id="3"></a>Syntax and Examples</h2>
            <p>The formal syntax to write a lambda function is as given below: </p>
            <pre class="code-toolbar"><code>  lambda p1, p2: expression
             </code></pre>
            <p>Here, p1 and p2 are the parameters which are passed to the lambda function. You can add as many or few
                parameters as you need. </p>
            <p>However, notice that we do not use brackets around the parameters as we do with regular functions. The
                last part (expression) is any valid python expression that operates on the parameters you provide to the
                function. </p>
            <h3>Example 1</h3>
            <p>Now that you know about lambdas let's try it with an example. So, open your IDLE and type in the
                following: </p>
            <pre class="code-toolbar"><code>
         adder = lambda x, y: x + y
         print (adder (1, 2))
         </code></pre>
            <p><strong>Here is the output:</strong> </p>
            <pre class="code-toolbar"><code>   3 </code></pre>
            <h3>Code Explanation </h3>
            <p>Here, we define a variable that will hold the result returned by the lambda function. </p>
            <p><strong>1.</strong> The lambda keyword used to define an anonymous function. </p>
            <p><strong>2.</strong> x and y are the parameters that we pass to the lambda function. </p>
            <p><strong>3.</strong> This is the body of the function, which adds the 2 parameters we passed. Notice that
                it is a single expression. You cannot write multiple statements in the body of a lambda function. </p>
            <p><strong>4.</strong> We call the function and print the returned value. </p>
            <h3>Example 2</h3>
            <p>That was a basic example to understand the fundamentals and syntax of lambda. Let's now try to print out
                a lambda and see the result. Again, open your IDLE and type in the following: </p>
            <pre class="code-toolbar"><code>
         #What a lambda returns
         string='some kind of a useless lambda'
         print(lambda string : print(string))
         </code></pre>
            <p>Now save your file and hit F5 to run the program. This is the output you should get. </p>
            <p><strong>Output:</strong> </p>

            <pre class="code-toolbar"><code>&lt;function &lt;lambda&gt; at 0x00000185C3BF81E0&gt;
         </code></pre>
            <p>What's happening here? Let's look at the code to understand further. </p>
            <p>Code Explanation </p>
            <ol>
                <li>Here, we define a string that you'll pass as a parameter to the lambda.</li>
                <li>We declare a lambda that calls a print statement and prints the result.</li>
            </ol>
            <p>But why doesn't the program print the string we pass? This is because the lambda itself returns a
                function object. In this example, the lambda is not being <strong>called</strong> by the print function
                but simply <strong>returning</strong> the function object and the memory location where it is stored.
                That's what gets printed at the console. </p>
            <h3>Example 3</h3>
            <p>However, if you write a program like this: </p>
            <pre class="code-toolbar"><code>
         #What a lambda returns #2
         x="some kind of a useless lambda"
         (lambda x : print(x))(x)
         </code></pre>
            <p>And run it by hitting F5, you'll see an output like this. </p>
            <p><strong>Output:</strong> </p>
            <pre class="code-toolbar"><code>some kind of a useless lambda</code></pre>
            <p>Now, the lambda is being called, and the string we pass gets printed at the console. But what is that
                weird syntax, and why is the lambda definition covered in brackets? Let's understand that now. </p>
            <p>Code Explanation </p>
            <ol>
                <li>Here is the same string we defined in the previous example.</li>
                <li>In this part, we are defining a lambda and calling it immediately by passing the string as an
                    argument. This is something called an IIFE, and you'll learn more about it in the upcoming sections
                    of this tutorial.</li>
            </ol>
            <h3>Example 4</h3>
            <p>Let's look at a final example to understand how lambdas and regular functions are executed. So, open your
                IDLE and in a new file, type in the following: </p>
            <pre class="code-toolbar"><code>
         #A REGULAR FUNCTION
         def girish( funct, *args ):
         funct( *args )
         def printer_one( arg ):
         return print (arg)
         def printer_two( arg ):
         print(arg)
         #CALL A REGULAR FUNCTION 
         girish( printer_one, 'printer 1 REGULAR CALL' )
         girish( printer_two, 'printer 2 REGULAR CALL \n' )
         #CALL A REGULAR FUNCTION THRU A LAMBDA
         girish(lambda: printer_one('printer 1 LAMBDA CALL'))
         girish(lambda: printer_two('printer 2 LAMBDA CALL'))
         </code></pre>
            <p>Now, save the file and hit F5 to run the program. If you didn't make any mistakes, the output should be
                something like this. </p>
            <p><strong>Output:</strong> </p>
            <p>printer 1 REGULAR CALL </p>
            <p>printer 2 REGULAR CALL </p>
            <p>printer 1 LAMBDA CALL </p>
            <p>printer 2 LAMBDA CALL </p>
            <p>Code Explanation </p>
            <ol>
                <li>A function called girish that takes another function as the first parameter and any other arguments
                    following it.</li>
                <li>printer_one is a simple function which prints the parameter passed to it and returns it. </li>
                <li>printer_two is similar to printer_one but without the return statement.</li>
                <li>In this part, we are calling the girish function and passing the printer functions and a string as
                    parameters.</li>
                <li>This is the syntax to achieve the fourth step (i.e., calling the girish function) but using lambdas.
                </li>
            </ol>
            <p>In the next section, you will learn how to use lambda functions with <strong>map(),</strong>
                <strong>reduce(),</strong> and <strong>filter()</strong> in Python. </p>
            <h2><a id="4"></a>Using lambdas with Python built-ins</h2>
            <p>Lambda functions provide an elegant and powerful way to perform operations using built-in methods in
                Python. It is possible because lambdas can be invoked immediately and passed as an argument to these
                functions. </p>
            <h3>IIFE in Python Lambda</h3>
            <p><strong>IIFE</strong> stands for <strong>immediately invoked function execution. </strong>It means that a
                lambda function is callable as soon as it is defined. Let's understand this with an example; fire up
                your IDLE and type in the following:</p>

            <pre class="code-toolbar"><code> (lambda x: x + x)(2) </code></pre>
            <p><strong>Here is the output and code explanation:</strong> </p>
            <p>This ability of lambdas to be invoked immediately allows you to use them inside functions like map() and
                reduce(). It is useful because you may not want to use these functions again. </p>
            <h2><a id="5"></a>lambdas in filter()</h2>
            <p>The filter function is used to select some particular elements from a sequence of elements. The sequence
                can be any iterator like lists, sets, tuples, etc. </p>
            <p>The elements which will be selected is based on some pre-defined constraint. It takes 2 parameters: </p>
            <ul>
                <li>A function that defines the filtering constraint</li>
                <li>A sequence (any iterator like lists, tuples, etc.)</li>
            </ul>
            <p>For example, </p>
            <pre class="code-toolbar"><code>
         sequences = [10,2,8,7,5,4,3,11,0, 1]
         filtered_result = filter (lambda x: x &gt; 4, sequences) 
         print(list(filtered_result))
         </code></pre>
            <p><strong>Here's the output:</strong> </p>
            <pre class="code-toolbar"><code>[10, 8, 7, 5, 11]</code></pre>
            <p><strong>Code Explanation:</strong> </p>
            <p><strong>1.</strong> In the first statement, we define a list called sequences which contains some
                numbers. </p>
            <p><strong>2.</strong> Here, we declare a variable called filtered_result, which will store the filtered
                values returned by the filter() function. </p>
            <p><strong>3.</strong> A lambda function which runs on each element of the list and returns true if it is
                greater than 4. </p>
            <p><strong>4. </strong>Print the result returned by the filter function. </p>
            <h2><a id="6"></a>lambdas in map()</h2>
            <p>the map function is used to apply a particular operation to every element in a sequence. Like filter(),
                it also takes 2 parameters: </p>
            <ol>
                <li>A function that defines the op to perform on the elements</li>
                <li>One or more sequences</li>
            </ol>
            <p>For example, here is a program that prints the squares of numbers in a given list: </p>
            <pre class="code-toolbar"><code>sequences = [10,2,8,7,5,4,3,11,0, 1]
         filtered_result = map (lambda x: x*x, sequences) 
         print(list(filtered_result))
         </code></pre>
            <p><strong>Output:</strong> </p>
            <pre class="code-toolbar"><code> [100, 4, 64, 49, 25, 16, 121, 0, 1]</code></pre>
            <p>[KR1] </p>
            <p>Code Explanation: </p>
            <ol>
                <li>Here, we define a list called sequences which contains some numbers. </li>
                <li>We declare a variable called filtered_result which will store the mapped values </li>
                <li>A lambda function which runs on each element of the list and returns the square of that number.
                </li>
                <li>Print the result returned by the map function. </li>
            </ol>
            <h2><a id="7"></a>lambdas in reduce[vV2][J3]()</h2>
            <p>The reduce function, like map(), is used to apply an operation to every element in a sequence. However,
                it differs from the map in its working. These are the steps followed by the reduce() function to compute
                an output: </p>
            <p><strong>Step 1) </strong>Perform the defined operation on the first 2 elements of the sequence. </p>
            <p><strong>Step 2) </strong>Save this result</p>

            <p><strong>Step 3) </strong>Perform the operation with the saved result and the next element in the
                sequence. </p>
            <p><strong>Step 4) </strong>Repeat until no more elements are left. </p>
            <p>It also takes two parameters: </p>
            <ol>
                <li>A function that defines the operation to be performed</li>
                <li>A sequence (any iterator like lists, tuples, etc.)</li>
            </ol>
            <p>For example, here is a program that returns the product of all elements in a list: </p>
            <pre class="code-toolbar"><code>
         from functools import reduce
         sequences = [1,2,3,4,5]
         product = reduce (lambda x, y: x*y, sequences)
         print(product)
         </code></pre>
            <p><strong>Here is the output:</strong> </p>
            <pre class="code-toolbar"><code>120</code></pre>
            <p>Code Explanation: </p>
            <ol>
                <li>Import reduce from the functools module </li>
                <li>Here, we define a list called sequences which contains some numbers. </li>
                <li>We declare a variable called product which will store the reduced value </li>
                <li>A lambda function that runs on each element of the list. It will return the product of that number
                    as per the previous result. </li>
                <li>Print the result returned by the reduce function. </li>
            </ol>
            <h2><a id="8"></a>Why (and why not) use lambda functions?</h2>
            <p>As you will see in the next section, lambdas are treated the same as regular functions at the interpreter
                level. In a way, you could say that lambdas provide compact syntax for writing functions which return a
                single expression. </p>
            <p>However, you should know when it is a good idea to use lambdas and when to avoid them. In this section,
                you will learn some of the design principles used by python developers when writing lambdas. </p>
            <p>One of the most common use cases for lambdas is in functional programming as Python supports a paradigm
                (or style) of programming known as functional programming. </p>
            <p>It allows you to provide a function as a parameter to another function (for example, in map, filter,
                etc.). In such cases, using lambdas offer an elegant way to create a one-time function and pass it as
                the parameter. </p>
            <h3>When should you not use Lambda?</h3>
            <p>You should never write complicated lambda functions in a production environment. It will be very
                difficult for coders who maintain your code to decrypt it. If you find yourself making complex one-liner
                expressions, it would be a much superior practice to define a proper function. As a best practice, you
                need to remember that simple code is always better than complex code. </p>
            <h2><a id="9"></a>Lambdas vs. Regular functions</h2>
            <p>As previously stated, lambdas are[vV4][J5] just functions which do not have an identifier bound to them.
                In simpler words, they are functions with no names (hence, anonymous). Here is a table to illustrate the
                difference between lambdas and regular functions in python. </p>
            <p><strong>Lambdas</strong> </p>
            <p><strong>Regular Functions</strong> </p>
            <p>Syntax: </p>
            <pre class="code-toolbar"><code>lambda x : x + x </code></pre>
            <p>Syntax: </p>
            <pre class="code-toolbar"><code>def (x) :
         return x + x 
         </code></pre>
            <p>Lambda functions can only have one expression in their body. </p>
            <p>Regular functions can have multiple expressions and statements in their body. </p>
            <p>Lambdas do not have a name associated with them. That's why they are also known as anonymous functions.
            </p>
            <p>Regular functions must have a name and signature. </p>
            <p>Lambdas do not contain a return statement because the body is automatically returned. </p>
            <p>Functions which need to return value should include a return statement. </p>
            <h3>Explanation of the differences?</h3>
            <p>The primary difference between a lambda and a regular function is that the lambda function evaluates only
                a single expression and yields a function object. Consequently, we can name the result of the lambda
                function and use it in our program as we did in the previous example. </p>
            <p>A regular function for the above example would look like this: </p>
            <pre class="code-toolbar"><code>
         def adder (x, y):
         return x + y 
         print (adder (1, 2))
         </code></pre>
            <p>Here, we have to define a <strong>name</strong> for the function which <strong>returns </strong>the
                result when we <strong>call</strong> it. A lambda function doesn't contain a return statement because it
                will have only a single expression which is always returned by default. You don't even have to assign a
                lambda either as it can be immediately invoked (see the next section). As you will see in the following
                example, lambdas become particularly powerful when we use them with Python's built-in functions. </p>
            <p>However, you may still be wondering how lambdas are any different from a function that returns a single
                expression (like the one above). At the interpreter level, there is not much difference. It may sound
                surprising, but any lambda function that you define in Python is treated as a normal function by the
                interpreter. </p>
            <p>As you can see in the diagram, the two definitions are handled in the same way by the python interpreter
                when converted to bytecode. Now, you cannot name a function <strong>lambda</strong> because it is
                reserved by Python, but any other function name will yield the same bytecode[KR6]. </p>
            <h3>Summary </h3>
            <ul>
                <li>Lambdas, also known as anonymous functions, are small, restricted functions which do not need a name
                    (i.e., an identifier).</li>
                <li>Every lambda function in Python has 3 essential parts:</li>
                <li>The lambda keyword.</li>
                <li>The parameters (or bound variables), and</li>
                <li>The function body.</li>
                <li>The syntax for writing a lambda is: lambda parameter: expression</li>
                <li>Lambdas can have any number of parameters, but they are not enclosed in braces</li>
                <li>A lambda can have only 1 expression in its function body, which is returned by default.</li>
                <li>At the bytecode level, there is not much difference between how lambdas and regular functions are
                    handled by the interpreter.</li>
                <li>Lambdas support IIFE thru this syntax: (lambda parameter: expression)(argument) </li>
                <li>Lambdas are commonly used with the following python built-ins:</li>
                <li>Filter: filter (lambda parameter: expression, iterable-sequence) </li>
                <li>Map: map (lambda parameter: expression, iterable-sequences) </li>
                <li>Reduce: reduce (lambda parameter1, parameter2: expression, iterable-sequence) </li>
                <li>Do not write complicated lambda functions in a production environment because it will be difficult
                    for code-maintainers.</li>
            </ul>
            

        </div>

    </div>
</section>
{% include blogslide.html %}