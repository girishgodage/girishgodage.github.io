I"0å<h2 id="middlewares">Middlewares</h2>

<p>Wow, it is already the sixth part of this series. In this chapter I‚Äôm going to write about Middlewares and how you can use them to customize your app a little more. I quickly go through the basics about Middlewares and then I‚Äôll write about some more special things you can do with Middlewares.</p>

<h2 id="about-middlewares">About Middlewares</h2>

<p>The most of you already know what Middlewares are, but some of you maybe not. Even if you already use ASP.NET Core for a while, you don‚Äôt really need to know details about Middlewares, because they are mostly hidden behind nicely named extension methods like <code class="language-plaintext highlighter-rouge">UseMvc()</code>, <code class="language-plaintext highlighter-rouge">UseAuthentication()</code>, <code class="language-plaintext highlighter-rouge">UseDeveloperExceptionPage()</code> and so on. Every time you call a <code class="language-plaintext highlighter-rouge">Use</code>-method in the <code class="language-plaintext highlighter-rouge">Startup.cs</code> in the <code class="language-plaintext highlighter-rouge">Configure</code> method, you‚Äôll implicitly use at least one or maybe more Middlewares.</p>

<p>A middleware is a peace of code that handles the request pipeline. Imagine the request pipeline as huge tube where you can call something in and where an echo comes back. The Middlewares are responsible for the creation of this echo or to manipulate the sound, to enrich the information or to handle the source sound or to handle the echo.</p>

<p>Middlewares are executed in the order they are configured. The first configured middleware is the first that gets executed.</p>

<p>In an ASP.NET Core web, if the client requests an image or any other static file, the <code class="language-plaintext highlighter-rouge">StaticFileMiddleware</code> searches for that resource and return that resource if it finds one. If not this middleware does nothing except to call the next one. If there is no last middleware that handles the request pipeline, the request returns nothing. The <code class="language-plaintext highlighter-rouge">MvcMiddleware</code> also checks the requested resource, tries to map it to a configured route, executes the controller, creates a view and returns a HTML or Web API result. If the <code class="language-plaintext highlighter-rouge">MvcMiddleware</code> does not find a matching controller, it anyway will return a result in this case it is a 404 Status result. It returns an echo in any case. This is why the <code class="language-plaintext highlighter-rouge">MvcMiddleware</code> is the last configured middleware.</p>

<p><img src="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/index/_static/request-delegate-pipeline.png?view=aspnetcore-2.1" alt="" /></p>

<p>(Image source: <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-2.1">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-2.1</a>)</p>

<p>An exception handling middleware is usually one of the first configured middlewares, but it is not because it gets executed first, but at last. The first configured middleware is also the last one if the echo comes back from the tube. An exception handling middleware validates the result and displays a possible exception in a browser and client friendly way. This is where a runtime error gets a 500 Status.</p>

<p>You are able to see how the pipeline is executed if you create an empty ASP.NET Core application. I usually use the console and the .NET CLI tools:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dotnet new web <span class="nt">-n</span> MiddlewaresSample <span class="nt">-o</span> MiddlewaresSample
<span class="nb">cd </span>MiddlewaresSample
</code></pre></div></div>

<p>Open the Startup.cs with your favorite editor. It should be pretty empty compared to a regular ASP.NET Core application. Rewrite the <code class="language-plaintext highlighter-rouge">Configure()</code> method like this:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">Startup</span>
<span class="p">{</span>
    <span class="c1">// This method gets called by the runtime. </span>
    <span class="c1">// Use this method to add services to the container.</span>
    <span class="c1">// For more information on how to configure your application, </span>
    <span class="c1">// visit https://go.microsoft.com/fwlink/?LinkID=398940</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">ConfigureServices</span><span class="p">(</span><span class="n">IServiceCollection</span> <span class="n">services</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="c1">// This method gets called by the runtime. </span>
    <span class="c1">// Use this method to configure the HTTP request pipeline.</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">Configure</span><span class="p">(</span><span class="n">IApplicationBuilder</span> <span class="n">app</span><span class="p">,</span> <span class="n">IWebHostEnvironment</span> <span class="n">env</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="nf">IsDevelopment</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="n">app</span><span class="p">.</span><span class="nf">UseDeveloperExceptionPage</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="n">app</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="k">async</span> <span class="n">context</span> <span class="p">=&gt;</span> 
        <span class="p">{</span>
            <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="n">Response</span><span class="p">.</span><span class="nf">WriteAsync</span><span class="p">(</span><span class="s">"Hello World!"</span><span class="p">);</span>
        <span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>There is the <code class="language-plaintext highlighter-rouge">DeveloperExceptionPageMiddleware</code> used and a special lambda Middleware that only writes ‚ÄúHello World!‚Äù to the response stream. The response stream is the echo I wrote about previously. This special middleware stops the pipeline and returns something like an echo. So it is the last one.</p>

<p>Leave this middleware and add the following lines right before the <code class="language-plaintext highlighter-rouge">app.Run()</code>:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">app</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="k">async</span> <span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">next</span><span class="p">)</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="n">Response</span><span class="p">.</span><span class="nf">WriteAsync</span><span class="p">(</span><span class="s">"==="</span><span class="p">);</span>
    <span class="k">await</span> <span class="nf">next</span><span class="p">();</span>
    <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="n">Response</span><span class="p">.</span><span class="nf">WriteAsync</span><span class="p">(</span><span class="s">"==="</span><span class="p">);</span>
<span class="p">});</span>
<span class="n">app</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="k">async</span> <span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">next</span><span class="p">)</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="n">Response</span><span class="p">.</span><span class="nf">WriteAsync</span><span class="p">(</span><span class="s">"&gt;&gt;&gt;&gt;&gt;&gt; "</span><span class="p">);</span>
    <span class="k">await</span> <span class="nf">next</span><span class="p">();</span>
    <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="n">Response</span><span class="p">.</span><span class="nf">WriteAsync</span><span class="p">(</span><span class="s">" &lt;&lt;&lt;&lt;&lt;&lt;"</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<p>These two calls of <code class="language-plaintext highlighter-rouge">app.Use()</code> also create two lambda Middlewares, but this time the Middlewares are calling the next ones. Each middleware knows the next one and calls it. Both middlewares writing to the response stream before and after the next middleware are called. This should demonstrate how the pipeline works. Before the next middleware is called the actual request is handled and after the next middleware is called, the response (echo) is handled.</p>

<p>If you now run the application (using <code class="language-plaintext highlighter-rouge">dotnet run</code>) and open the displayed URL in the browser, you should see a plain text result like this:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>===&gt;&gt;&gt;&gt;&gt;&gt; Hello World! &lt;&lt;&lt;&lt;&lt;&lt;===
</code></pre></div></div>

<p>Does this make sense to you? If yes, let‚Äôs see how to use this concept to add some additional functionality to the request pipeline.</p>

<h2 id="writing-a-custom-middleware">Writing a custom middleware</h2>

<p>ASP.NET Core is based on Middlewares. All the logic that gets executed during a request is somehow based on a middleware. So we are able to use this to add custom functionality to the web. We want to know the execution time of every request that goes through the request pipeline. I do this by creating and starting a <code class="language-plaintext highlighter-rouge">Stopwatch</code> before the next middleware is called and by stop measuring the execution time after the next middleware is called:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">app</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="k">async</span> <span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">next</span><span class="p">)</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">s</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Stopwatch</span><span class="p">();</span>
    <span class="n">s</span><span class="p">.</span><span class="nf">Start</span><span class="p">();</span>
    
    <span class="c1">// execute the rest of the pipeline</span>
    <span class="k">await</span> <span class="nf">next</span><span class="p">();</span>
    
    <span class="n">s</span><span class="p">.</span><span class="nf">Stop</span><span class="p">();</span> <span class="c1">//stop measuring</span>
    <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="n">s</span><span class="p">.</span><span class="n">ElapsedMilliseconds</span><span class="p">;</span>
    
    <span class="c1">// write out the milliseconds needed</span>
    <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="n">Response</span><span class="p">.</span><span class="nf">WriteAsync</span><span class="p">(</span><span class="s">$"Time needed: </span><span class="p">{</span><span class="n">result</span> <span class="p">}</span><span class="s">"</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<p>After that I write out the elapsed milliseconds to the response stream.</p>

<p>If you write some more Middlewares the <code class="language-plaintext highlighter-rouge">Configure</code> method in the <code class="language-plaintext highlighter-rouge">Startup.cs</code> gets pretty messy. This is why the most Middlewares are written as separate classes. This could look like this:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">StopwatchMiddleWare</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">RequestDelegate</span> <span class="n">_next</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">StopwatchMiddleWare</span><span class="p">(</span><span class="n">RequestDelegate</span> <span class="n">next</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_next</span> <span class="p">=</span> <span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">Invoke</span><span class="p">(</span><span class="n">HttpContext</span> <span class="n">context</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">s</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Stopwatch</span><span class="p">();</span>
        <span class="n">s</span><span class="p">.</span><span class="nf">Start</span><span class="p">();</span>

        <span class="c1">// execute the rest of the pipeline</span>
        <span class="k">await</span> <span class="nf">next</span><span class="p">();</span>

        <span class="n">s</span><span class="p">.</span><span class="nf">Stop</span><span class="p">();</span> <span class="c1">//stop measuring</span>
        <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="n">s</span><span class="p">.</span><span class="n">ElapsedMilliseconds</span><span class="p">;</span>

        <span class="c1">// write out the milliseconds needed</span>
        <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="n">Response</span><span class="p">.</span><span class="nf">WriteAsync</span><span class="p">(</span><span class="s">$"Time needed: </span><span class="p">{</span><span class="n">result</span> <span class="p">}</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This way we get the next middleware via the constructor and the current context in the <code class="language-plaintext highlighter-rouge">Invoke()</code> method.</p>

<blockquote>
  <p>Note: The Middleware is initialized on the start of the application and exists once during the application lifetime. The constructor gets called once. On the other hand the Invoke() method is called once per request.</p>
</blockquote>

<p>To use this middleware, there is a generic <code class="language-plaintext highlighter-rouge">UseMiddleware()</code> method available you can use in the configure method:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">app</span><span class="p">.</span><span class="n">UseMiddleware</span><span class="p">&lt;</span><span class="n">StopwatchMiddleware</span><span class="p">&gt;();</span>
</code></pre></div></div>

<p>The more elegant way is to create an extensions method that encapsulates this call:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">StopwatchMiddlewareExtension</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="n">IApplicationBuilder</span> <span class="nf">UseStopwatch</span><span class="p">(</span><span class="k">this</span> <span class="n">IApplicationBuilder</span> <span class="n">app</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">app</span><span class="p">.</span><span class="n">UseMiddleware</span><span class="p">&lt;</span><span class="n">StopwatchMiddleware</span><span class="p">&gt;();</span>
        <span class="k">return</span> <span class="n">app</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now you can simply call it like this:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">app</span><span class="p">.</span><span class="nf">UseStopwatch</span><span class="p">();</span>
</code></pre></div></div>

<p>This is the way you can provide additional functionality to a ASP.NET Core web through the request pipeline. You are able to manipulate the request or even the response using Middlewares.</p>

<p>The <code class="language-plaintext highlighter-rouge">AuthenticationMiddleware</code> for example tries to request user information from the request. If it doesn‚Äôt find any, it asked the client about it by sending a specific response back to the client. If it finds some, it adds the information to the request context and makes it available to the entire application this way.</p>

<h2 id="what-else-can-we-do-using-middlewares">What else can we do using Middlewares?</h2>

<p>Did you know that you can divert the request pipeline into two or more branches?</p>

<p>The next snippet shows how to create branches based on specific paths:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">app</span><span class="p">.</span><span class="nf">Map</span><span class="p">(</span><span class="s">"/map1"</span><span class="p">,</span> <span class="n">app1</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="c1">// some more Middlewares</span>
    
    <span class="n">app1</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="k">async</span> <span class="n">context</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="n">Response</span><span class="p">.</span><span class="nf">WriteAsync</span><span class="p">(</span><span class="s">"Map Test 1"</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">});</span>

<span class="n">app</span><span class="p">.</span><span class="nf">Map</span><span class="p">(</span><span class="s">"/map2"</span><span class="p">,</span> <span class="n">app2</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="c1">// some more Middlewares</span>
    
    <span class="n">app2</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="k">async</span> <span class="n">context</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="n">Response</span><span class="p">.</span><span class="nf">WriteAsync</span><span class="p">(</span><span class="s">"Map Test 2"</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">});</span>

<span class="c1">// some more Middlewares</span>

<span class="n">app</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="k">async</span> <span class="p">(</span><span class="n">context</span><span class="p">)</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="n">Response</span><span class="p">.</span><span class="nf">WriteAsync</span><span class="p">(</span><span class="s">"Hello World!"</span><span class="p">);</span>
<span class="p">});</span>

</code></pre></div></div>

<p>The path ‚Äú/map1‚Äù is a specific branch that continues the request pipeline inside. The same with ‚Äú/map2‚Äù. Both maps have their own middleware configurations inside. All other not specified paths will follow the main branch.</p>

<p>There is also a <code class="language-plaintext highlighter-rouge">MapWhen()</code> method to branch the pipeline based on a condition instead of branch based on a path:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">void</span> <span class="nf">Configure</span><span class="p">(</span><span class="n">IApplicationBuilder</span> <span class="n">app</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">app</span><span class="p">.</span><span class="nf">MapWhen</span><span class="p">(</span><span class="n">context</span> <span class="p">=&gt;</span> <span class="n">context</span><span class="p">.</span><span class="n">Request</span><span class="p">.</span><span class="n">Query</span><span class="p">.</span><span class="nf">ContainsKey</span><span class="p">(</span><span class="s">"branch"</span><span class="p">),</span>
                <span class="n">app1</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="c1">// some more Middlewares</span>
    
        <span class="n">app1</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="k">async</span> <span class="n">context</span> <span class="p">=&gt;</span>
        <span class="p">{</span>
            <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="n">Response</span><span class="p">.</span><span class="nf">WriteAsync</span><span class="p">(</span><span class="s">"MapBranch Test"</span><span class="p">);</span>
        <span class="p">});</span>
    <span class="p">});</span>

    <span class="c1">// some more Middlewares</span>
    
    <span class="n">app</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="k">async</span> <span class="n">context</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="n">Response</span><span class="p">.</span><span class="nf">WriteAsync</span><span class="p">(</span><span class="s">"Hello from non-Map delegate. &lt;p&gt;"</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">}</span>

</code></pre></div></div>

<p>You can create conditions based on configuration values or as shown here, based on properties of the request context. In this case a query string property is used. You can use HTTP headers, form properties or any other property of the request context.</p>

<p>You are also able to nest the maps to create child and grandchild branches if needed.</p>

<p><code class="language-plaintext highlighter-rouge">Map()</code> or <code class="language-plaintext highlighter-rouge">MapWhen()</code> is used to provide a special API or resource based an a specific path or a specific condition. The ASP.NET Core HealthCheck API is done like this. It first uses <code class="language-plaintext highlighter-rouge">MapWhen()</code> to specify the port to use and then the <code class="language-plaintext highlighter-rouge">Map()</code> to set the path for the HealthCheck API, or it uses <code class="language-plaintext highlighter-rouge">Map()</code> only if no port is specified. At the end the HealthCheckMiddleware is used:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">UseHealthChecksCore</span><span class="p">(</span><span class="n">IApplicationBuilder</span> <span class="n">app</span><span class="p">,</span> <span class="n">PathString</span> <span class="n">path</span><span class="p">,</span> <span class="kt">int</span><span class="p">?</span> <span class="n">port</span><span class="p">,</span> <span class="kt">object</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">port</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">app</span><span class="p">.</span><span class="nf">Map</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">b</span> <span class="p">=&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">UseMiddleware</span><span class="p">&lt;</span><span class="n">HealthCheckMiddleware</span><span class="p">&gt;(</span><span class="n">args</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">app</span><span class="p">.</span><span class="nf">MapWhen</span><span class="p">(</span>
            <span class="n">c</span> <span class="p">=&gt;</span> <span class="n">c</span><span class="p">.</span><span class="n">Connection</span><span class="p">.</span><span class="n">LocalPort</span> <span class="p">==</span> <span class="n">port</span><span class="p">,</span>
            <span class="n">b0</span> <span class="p">=&gt;</span> <span class="n">b0</span><span class="p">.</span><span class="nf">Map</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">b1</span> <span class="p">=&gt;</span> <span class="n">b1</span><span class="p">.</span><span class="n">UseMiddleware</span><span class="p">&lt;</span><span class="n">HealthCheckMiddleware</span><span class="p">&gt;(</span><span class="n">args</span><span class="p">)));</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<p>(See <a href="https://github.com/aspnet/Diagnostics/blob/release/2.2/src/Microsoft.AspNetCore.Diagnostics.HealthChecks/Builder/HealthCheckApplicationBuilderExtensions.cs">here on GitHib</a>)</p>

<blockquote>
  <p>Another question that is Middlewares related, I am not sure why I never seen anyone using IMiddleware instead of writing InvokeAsync manually?!!</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">IMiddleware</code> is new in ASP.NET Core 2.0 and actually I never knew that it existed before he tweeted about it. I‚Äôll definitely have a deeper look into <code class="language-plaintext highlighter-rouge">IMiddleware</code> and will write about it. Until that you should read Hishams really good post about it: <a href="http://www.hishambinateya.com/why-you-arenot-using-imiddleware">Why you aren‚Äôt using IMiddleware?</a></p>

<h2 id="update-on-aspnet-core-30">Update on ASP.NET Core 3.0</h2>

<p>In new ASP.NET Core 3.0 projects the Configure() method looks different. There are two new kind off Middleware elements called:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">void</span> <span class="nf">Configure</span><span class="p">(</span><span class="n">IApplicationBuilder</span> <span class="n">app</span><span class="p">,</span> <span class="n">IWebHostEnvironment</span> <span class="n">env</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="nf">IsDevelopment</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">app</span><span class="p">.</span><span class="nf">UseDeveloperExceptionPage</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">app</span><span class="p">.</span><span class="nf">UseRouting</span><span class="p">();</span>

    <span class="n">app</span><span class="p">.</span><span class="nf">UseEndpoints</span><span class="p">(</span><span class="n">endpoints</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="n">endpoints</span><span class="p">.</span><span class="nf">MapGet</span><span class="p">(</span><span class="s">"/"</span><span class="p">,</span> <span class="k">async</span> <span class="n">context</span> <span class="p">=&gt;</span>
        <span class="p">{</span>
            <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="n">Response</span><span class="p">.</span><span class="nf">WriteAsync</span><span class="p">(</span><span class="s">"Hello World!"</span><span class="p">);</span>
        <span class="p">});</span>
    <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The first one is a middleware that uses routing and the other one uses endpoints. What exactly is this?</p>

<p>This is the new so called endpoint routing. In ASP.NET Core 3.0 routing got moved out of the MVC framework. Previously it was part of MVC and only worked with MVC, Web API and frameworks that are based on the MVC Framework. Now MVC and the other frameworks are mapped to a specific route or endpoint. There are different kinds of endpoint definitions available.</p>

<p>In the snippet above a GET request gets mapped to the page root URL. In the next snippet MVC is mapped to a route pattern and Razor Pages are mapped to the razor pages specific file structure based routes:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">app</span><span class="p">.</span><span class="nf">UseEndpoints</span><span class="p">(</span><span class="n">endpoints</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="n">endpoints</span><span class="p">.</span><span class="nf">MapControllerRoute</span><span class="p">(</span>
        <span class="n">name</span><span class="p">:</span> <span class="s">"default"</span><span class="p">,</span>
        <span class="n">pattern</span><span class="p">:</span> <span class="s">"{controller=Home}/{action=Index}/{id?}"</span><span class="p">);</span>
    <span class="n">endpoints</span><span class="p">.</span><span class="nf">MapRazorPages</span><span class="p">();</span>
<span class="p">});</span>
</code></pre></div></div>

<p>Yes. There is no <code class="language-plaintext highlighter-rouge">UseMvc()</code> used anymore, even if it still exists and is still working on the <code class="language-plaintext highlighter-rouge">IApplicationBiulder</code> level to not break existing code. Now there are new methods to activate ASP.NET Core features more granularly.</p>

<p>These are the most used new Map methods for ASP.NET Core 3.0:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">endpoints</span><span class="p">.</span><span class="nf">MapAreaControllerRoute</span><span class="p">(...);</span> <span class="c1">// Areas for MVC &amp; WebAPI</span>
<span class="n">endpoints</span><span class="p">.</span><span class="nf">MapControllerRoute</span><span class="p">(...);</span> <span class="c1">// MVC &amp; WebAPI</span>
<span class="n">endpoints</span><span class="p">.</span><span class="nf">MapBlazorHub</span><span class="p">(...);</span> <span class="c1">// Blazor Server Side</span>
<span class="n">endpoints</span><span class="p">.</span><span class="nf">MapHub</span><span class="p">(...);</span> <span class="c1">// SignalR</span>
<span class="n">endpoints</span><span class="p">.</span><span class="nf">MapRazorPages</span><span class="p">(...);</span> <span class="c1">// Razor PAges</span>
<span class="n">endpoints</span><span class="p">.</span><span class="nf">MapHealthChecks</span><span class="p">(...);</span> <span class="c1">// Health Checks</span>
</code></pre></div></div>

<p>There are a lot more methods to define fallback endpoints, to map routes and HTTP methods to delegates and middlewares.</p>

<p>If you want to create middlewares that work on all request, like the <code class="language-plaintext highlighter-rouge">StopWatchMiddleware</code>, this will work as before on the <code class="language-plaintext highlighter-rouge">IApplicationBuilder</code>. If you have a Middleware that should work on a specific path or route, you should create a Map method for it to map it to that route. It is not longer recommended to handle the route inside the middleware. With this approach the middlewares are a lot more generic and they will work on multiple routes with a single configuration.</p>

<p>I recently wrote a Middleware to provide a GraphQL endpoint in a ASP.NET Core application. I wrote a Middleware for it and I needed to rewrite it to follow the ASP.NET Core 3.0 way of routing. The old way would still work, but will handle the paths and routes separately from the new ASP.NET Core routing.</p>

<p>Let‚Äôs quickly see how it looks like to write a Middleware that supports the new endpoint routing:</p>

<p>[TODO: Code]</p>

<h2 id="conclusion">Conclusion</h2>

<p>Most of the ASP.NET Core features are based on middlewares and we are able to extend ASP.NET Core by creating our own middlewares.</p>

<p>In the next two chapters I will have a look into different data types and how to handle them. I will create API outputs with any format and data type.</p>

<hr />
<h2 id="sessions">Sessions</h2>

<p>This is series of articles on Building Conf planner app with Asp.net Core:</p>

<ul>
  <li><a href="/blog/customize-logging" target="_blank">1 - Logging</a></li>
  <li><a href="/blog/customize-configuration" target="_blank">2 - Configuration</a></li>
  <li><a href="/blog/customize-dependency-injection" target="_blank">3 - Dependency Injection</a></li>
  <li><a href="/blog/customize-https" target="_blank">4 - Https</a></li>
  <li><a href="/blog/customize-hostedservices" target="_blank">5 - Hostedservices</a></li>
  <li><a href="/blog/customize-middleware" target="_blank">6 - Middlewares</a></li>
  <li><a href="/blog/customize-outputformatter" target="_blank">7 - Outputformatter</a></li>
  <li><a href="/blog/customize-modelbinders" target="_blank">8 - Modelbinders </a></li>
  <li><a href="/blog/customize-actionfilters" target="_blank">9 - Actionfilters</a></li>
  <li><a href="/blog/customize-taghelpers" target="_blank">10 - Taghelpers</a></li>
  <li><a href="/blog/customize-webhostbuilder" target="_blank">11 - Webhostbuilder</a></li>
  <li><a href="/blog/customize-hosting" target="_blank">12 - Hosting </a></li>
</ul>

<!--Section: Lesson UI-->
<section class="text-center">
    <hr />
   
    <div class="row">
        <div class="col-lg-4 col-md-6 col-sm-6">
            <a target="_blank" href="/blog/customize-hostedservices" class="btn  btn-sm" id="round-button">
                <i class="fas fa-arrow-left mr-2"></i>Previous Lesson
            </a>
        </div>
     
        <div class="col-lg-4 col-md-6 col-sm-6">
            <a target="_blank" href="/blog/customize-outputformatter" class="btn btn-sm" id="round-button">Next Lesson
                <i class="fas fa-arrow-right ml-2"></i>
            </a>
        </div>       
    </div>

</section>

:ET