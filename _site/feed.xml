<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-10-23T05:58:23+00:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Girish Godage</title><subtitle>I am a passionate Leader, who has a good command in technology &amp; Mangement. Also, I am a creative designer and an innovatie techie.</subtitle><author><name>Girish Godage</name></author><entry><title type="html">Asynchronous communication with queues and microservices - A perfect combination?</title><link href="http://localhost:4000/blog/asynchronous-communication-with-queues-in-microservices" rel="alternate" type="text/html" title="Asynchronous communication with queues and microservices - A perfect combination?" /><published>2019-10-19T20:17:00+00:00</published><updated>2019-10-19T20:17:00+00:00</updated><id>http://localhost:4000/blog/Microservices23</id><content type="html" xml:base="http://localhost:4000/blog/asynchronous-communication-with-queues-in-microservices">&lt;p&gt;In this article, we throw some light on what asynchronous messaging is all about and discuss why you should consider it for your microservices architectures.&lt;/p&gt;

&lt;h3 id=&quot;what-you-will-learn&quot;&gt;What you will learn&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;What is Asynchronous Communication?&lt;/li&gt;
  &lt;li&gt;Why Do We Need Asynchronous Communication?&lt;/li&gt;
  &lt;li&gt;How is Asynchronous Communication implemented?&lt;/li&gt;
  &lt;li&gt;Why should you consider using Asynchronous Communication for your microservices?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;what-is-synchronous-communication&quot;&gt;What Is Synchronous Communication?&lt;/h3&gt;

&lt;p&gt;Consider the following example of a microservices architecture:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Capture-046-02.png&quot; alt=&quot;image info&quot; /&gt;&lt;/p&gt;

&lt;p&gt;You have Microservice1 calling Microservice2, which in turn invokes Microservice3. Suppose that Microservice3 offers a simple web service functionality. So Microservice1 can send it a request for data over HTTP, and get back a response containing the requested data.&lt;/p&gt;

&lt;p&gt;The communication that exists between these two microservices is called &lt;strong&gt;synchronous communication&lt;/strong&gt;. Microservice1 sends the request, waits for the data to be returned, and then proceeds.&lt;/p&gt;

&lt;h4 id=&quot;drawbacks-of-synchronous-communication&quot;&gt;Drawbacks Of Synchronous Communication&lt;/h4&gt;

&lt;p&gt;This mode of communication works well when the response arrives almost immediately. However, it puts restrictions on the microservices that are involved. In order that Microservice1 be available, Microservice2 also needs to be available.&lt;/p&gt;

&lt;p&gt;In certain scenarios, synchronous communication might not even be user friendly.&lt;/p&gt;

&lt;p&gt;Let’s say Microservice2 is down. In that case, the user who submitted the request needs to be intimated about it. You don’t always want to do that. In such situations, &lt;strong&gt;asynchronous communication&lt;/strong&gt; provides a better alternative.&lt;/p&gt;

&lt;h3 id=&quot;asynchronous-communication&quot;&gt;Asynchronous Communication&lt;/h3&gt;

&lt;p&gt;Have a look at the following application architecture:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Capture-046-03.png&quot; alt=&quot;image info&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In the picture above, we make use of a ZipkinDistributedTracingServer. Different Microservices send logs that are finally consolidated in the Zipkin Tracing Service. Each microservice puts its tracing information into the RabbitMQ message queue. The server processes messages as and when they come into the queue.&lt;/p&gt;

&lt;p&gt;In this architecture, applications communicate through RabbitMQ. CurrencyCalculationService puts its own tracing information into RabbitMQ, and then forgets about it. It does not worry about the responses coming back to it.&lt;/p&gt;

&lt;p&gt;Now, what would happen if the ZipkinDistributedTracingServer were to go down?&lt;/p&gt;

&lt;p&gt;The services communicating with it would not worry one bit. They would continue sending messages to the queue. When the server comes back up, it resumes processing the messages present in the queue, and saves them to the database.&lt;/p&gt;

&lt;h4 id=&quot;advantages-of-asynchronous-communication&quot;&gt;Advantages Of Asynchronous Communication&lt;/h4&gt;

&lt;p&gt;Let’s look at a few advantages of asynchronous communication:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;In a system that involves asynchronous messaging, the server does not need to be up and running, all the time. Messages that are put into the message queue can be processed in batches, at a later time.&lt;/li&gt;
  &lt;li&gt;Instead of a single instance of the tracing server processing the message queue, you could spawn multiple instances to lighten the load.&lt;/li&gt;
  &lt;li&gt;If you use a modern version of a messaging queue, there is a good chance you get to use a replay feature. This helps in re-processing a message that initially threw an error.&lt;/li&gt;
  &lt;li&gt;Asynchronous communication is great for systems that require &lt;strong&gt;eventual consistency&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Great thing is as long as we fix the errors and reprocess the message, the users of services that initiated the requests with errors do not even need to know about them.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;limitations-of-asynchronous-communication&quot;&gt;Limitations Of Asynchronous Communication&lt;/h4&gt;

&lt;p&gt;Asynchronous communication cannot be used&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;If the processing needs to be real-time - if there is a hard constraint on the response time of a certain request.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;summary&quot;&gt;Summary&lt;/h3&gt;

&lt;p&gt;In this article, we had a look at what asynchronous communication is all about, We started with a peek at synchronous communication, and saw that it puts constraints on applications and their availability. Asynchronous communication solves the problem by causing services to enqueue requests into a message queue. A server then processes them independently, often in batches.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;best-practices-with-cloud-and-microservices&quot;&gt;Best Practices with Cloud and Microservices&lt;/h3&gt;

&lt;p&gt;This is the first article in a series of six articles on best practices with cloud and microservices:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/12-factor-app-cloud-native-microservices-best-practices&quot; target=&quot;_blank&quot;&gt;1 - The 12 Factor App - Best Practices In Cloud Native Applications and Microservices&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/introduction-to-event-driven-architectures-with-microservices&quot; target=&quot;_blank&quot;&gt;2 - Microservices Architectures - Event Driven Approach&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/software-best-practices-building-a-vertical-slice&quot; target=&quot;_blank&quot;&gt;3 - Why do you build a Vertical Slice?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/messaging-queues-and-asynchronous-communication-in-microservices&quot; target=&quot;_blank&quot;&gt;4 - Microservice Architecture Best Practices - Messaging Queues&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/creating-archetypes-in-microservices-architectures-best-practices&quot; target=&quot;_blank&quot;&gt;5 - Build an Archetype&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/asynchronous-communication-with-queues-in-microservices&quot; target=&quot;_blank&quot;&gt;6 - Asynchronous communication with queues and microservices - A perfect combination?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!--Section: Lesson UI--&gt;
&lt;section class=&quot;text-center&quot;&gt;
    &lt;hr /&gt;
   
    &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;col-lg-4 col-md-6 col-sm-6&quot;&gt;
            &lt;a target=&quot;_blank&quot; href=&quot;/blog/creating-archetypes-in-microservices-architectures-best-practices&quot; class=&quot;btn  btn-sm&quot; id=&quot;round-button&quot;&gt;
                &lt;i class=&quot;fas fa-arrow-left mr-2&quot;&gt;&lt;/i&gt;Previous Lesson
            &lt;/a&gt;
        &lt;/div&gt;
     
        &lt;div class=&quot;col-lg-4 col-md-6 col-sm-6&quot;&gt;
            &lt;a target=&quot;_blank&quot; href=&quot;/blog/asynchronous-communication-with-queues-in-microservices&quot; class=&quot;btn btn-sm&quot; id=&quot;round-button&quot;&gt;Next Lesson
                &lt;i class=&quot;fas fa-arrow-right ml-2&quot;&gt;&lt;/i&gt;
            &lt;/a&gt;
        &lt;/div&gt;       
    &lt;/div&gt;

&lt;/section&gt;</content><author><name>Girish Godage</name></author><category term="learning" /><summary type="html">In this article, we throw some light on what asynchronous messaging is all about and discuss why you should consider it for your microservices architectures.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/img/microservices.png" /></entry><entry><title type="html">Microservice Best Practice - Build an Archetype</title><link href="http://localhost:4000/blog/creating-archetypes-in-microservices-architectures-best-practices" rel="alternate" type="text/html" title="Microservice Best Practice - Build an Archetype" /><published>2019-10-19T20:17:00+00:00</published><updated>2019-10-19T20:17:00+00:00</updated><id>http://localhost:4000/blog/Microservices22</id><content type="html" xml:base="http://localhost:4000/blog/creating-archetypes-in-microservices-architectures-best-practices">&lt;p&gt;In this article, we focus on learning why creating proper archetypes is important for successful microservices architecture.&lt;/p&gt;

&lt;h1 id=&quot;what-you-will-learn&quot;&gt;What you will learn&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;What is an archetype?&lt;/li&gt;
  &lt;li&gt;Why do you want to build microservices quickly?&lt;/li&gt;
  &lt;li&gt;How does an archetype help?&lt;/li&gt;
  &lt;li&gt;How can you use an archetype?&lt;/li&gt;
  &lt;li&gt;How can you build an archetype of your own?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;why-do-we-need-archetypes&quot;&gt;Why Do We Need Archetypes?&lt;/h3&gt;

&lt;p&gt;In microservices architectures, we have a number of microservices interacting with each other. And, we keep adding microservices as we evolve.&lt;/p&gt;

&lt;p&gt;A few questions arise:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;How do you ensure that the microservices are consistent i.e. similarly built and deployed? This will ensure that a developer moving from one microservice to another will not have a great deal of learning to do!&lt;/li&gt;
  &lt;li&gt;How do you ensure that you are able to setup a new microservice quickly?&lt;/li&gt;
  &lt;li&gt;How do you ensure that the new microservice is consistent with older microservices?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With microservices architectures, while the functionality of each microservice is different, you want a bit of consistency in how they are built and deployed&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Programming Language used&lt;/li&gt;
  &lt;li&gt;Frameworks used&lt;/li&gt;
  &lt;li&gt;The way unit tests are written&lt;/li&gt;
  &lt;li&gt;Deployment and Monitoring processes&lt;/li&gt;
  &lt;li&gt;QA &amp;amp; Automation Testing Approaches&lt;/li&gt;
  &lt;li&gt;Integration with Infrastructure components like Naming Server, API Gateways etc&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This is where the reference architecture for your microservices comes into the picture. Having a good reference architecture ensures that your microservices are uniform.&lt;/p&gt;

&lt;p&gt;How do you ensure that the reference architecture is properly implemented?&lt;/p&gt;

&lt;h3 id=&quot;enter-archetypes&quot;&gt;Enter Archetypes&lt;/h3&gt;

&lt;p&gt;Creating an &lt;strong&gt;archetype&lt;/strong&gt; standardizes the reference architecture. An archetype is a piece of component code that can create the initial setup of microservice, adhering to the reference architecture.&lt;/p&gt;

&lt;p&gt;What would the output of an archetype look like?&lt;/p&gt;

&lt;p&gt;It would consist of an example microservice with&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Framework Integration&lt;/li&gt;
  &lt;li&gt;Configuration of common external components&lt;/li&gt;
  &lt;li&gt;Multiple layer Setup&lt;/li&gt;
  &lt;li&gt;Initial Security Configuration - For Authentication and Authorization&lt;/li&gt;
  &lt;li&gt;Sample Automation Tests for Unit Testing and Integration Testing&lt;/li&gt;
  &lt;li&gt;Infrastructure setup for communication with other microservices&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Once you generate a component using the archetype, you can focus on adding business features to your microservice.&lt;/p&gt;

&lt;h3 id=&quot;reference-archetype-example&quot;&gt;Reference Archetype Example&lt;/h3&gt;

&lt;p&gt;We have created a reference archetype for a Spring Boot Microservice. Github repo for the project is https://github.com/girishgodage/microservice-reference-archetype.&lt;/p&gt;

&lt;h4 id=&quot;using-the-archetype-to-create-a-new-project&quot;&gt;Using the archetype to create a new project&lt;/h4&gt;

&lt;p&gt;Steps are detailed below:&lt;/p&gt;

&lt;h5 id=&quot;download-or-clone-the-github-repository&quot;&gt;Download or Clone the github repository&lt;/h5&gt;

&lt;p&gt;You can start with cloning the repository - https://github.com/girishgodage/microservice-reference-archetype. Other option is to download the repository as a zip file using this link - https://github.com/girishgodage/microservice-reference-archetype/archive/master.zip&lt;/p&gt;

&lt;h5 id=&quot;install-the-archetype&quot;&gt;Install the archetype&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;cd to the root of the project and run&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mvn clean install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;This will install the archetype to your local repository&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[INFO] Installing /girishgodage/git/microservice-archetype/microservice-archetype/target/project-name-archetype-0.0.2-SNAPSHOT.jar to /Users/rangaraokaranam/.m2/repository/com/organization/project/project-name-archetype/0.0.2-SNAPSHOT/project-name-archetype-0.0.2-SNAPSHOT.jar
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;create-a-new-project-using-the-archetype&quot;&gt;Create a new project using the archetype&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Create a new folder on your hard drive. Let’s call it first-project&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Execute the following commands&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd first-project
mvn archetype:generate -DarchetypeCatalog=local
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;archetype plugin asks for a groupId and artifactId as shown below&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Choose a number or apply filter (format: [groupId:]artifactId, case sensitive contains): : 1
Define value for property 'groupId': com.first
Define value for property 'artifactId': first-project
Define value for property 'version' 1.0-SNAPSHOT: : 
Define value for property 'package' com.first: : 
Confirm properties configuration:
groupId: com.first
artifactId: first-project
version: 1.0-SNAPSHOT
package: com.first
 Y: : Y
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;When the archetype plugin executes successfully, you should see the message shown below:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[INFO] Project created from Archetype in dir: /girishgodage/git/microservice-archetype/first-project
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;verify-the-new-project&quot;&gt;Verify the new project&lt;/h5&gt;

&lt;p&gt;You can do a &lt;code class=&quot;highlighter-rouge&quot;&gt;mvn clean install&lt;/code&gt; on the new project in first-project to check it everything is good.&lt;/p&gt;

&lt;p&gt;This is a Spring Boot Project with a couple of controllers and unit/integration tests.&lt;/p&gt;

&lt;h3 id=&quot;creating-your-own-reference-archetype&quot;&gt;Creating Your Own Reference Archetype&lt;/h3&gt;

&lt;p&gt;You can also create a reference archetype of your own. The first thing you need to do is to create a reference project - which would serve as the base for creating your archetype.&lt;/p&gt;

&lt;h4 id=&quot;setting-up-reference-project&quot;&gt;Setting up Reference Project&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;We have our reference microservice in the folder microservice-reference. This is a Spring Boot Project with a couple of controllers and unit/integration tests. We use this as the reference project to reverse engineer an archetype.&lt;/li&gt;
  &lt;li&gt;When we create a new project using a maven archetype, the two important inputs are groupId and artifactId. In the reference project we would need to make sure that everything that needs to customized based on these inputs should be using similar values. In the microservice-reference, we use the following as the standard:
    &lt;ul&gt;
      &lt;li&gt;groupId - com.organization.project&lt;/li&gt;
      &lt;li&gt;artifactId - project-name&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;You would need to customize the reference-project to meet your needs or you can create a new reference-project.&lt;/li&gt;
  &lt;li&gt;Ensure that you configure the latest version of maven-archetype-plugin in your microservice-reference&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	&lt;span class=&quot;nt&quot;&gt;&amp;lt;build&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;pluginManagement&amp;gt;&lt;/span&gt;
			&lt;span class=&quot;nt&quot;&gt;&amp;lt;plugins&amp;gt;&lt;/span&gt;
				&lt;span class=&quot;nt&quot;&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;
					&lt;span class=&quot;nt&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;maven-archetype-plugin&lt;span class=&quot;nt&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
					&lt;span class=&quot;nt&quot;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;3.0.1&lt;span class=&quot;nt&quot;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
				&lt;span class=&quot;nt&quot;&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;
			&lt;span class=&quot;nt&quot;&gt;&amp;lt;/plugins&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;/pluginManagement&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;reverse-engineering-an-archetype-from-microservice-reference&quot;&gt;Reverse Engineering an Archetype from microservice-reference&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;In the command prompt cd to the folder containing this project&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd microservice-reference
mvn archetype:create-from-project
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;You will see the following statements in the log&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[INFO] Setting default groupId: com.organization.project
[INFO] Setting default artifactId: project-name
[INFO] Setting default version: 0.0.2-SNAPSHOT
[INFO] Setting default package: com.organization.project
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Archetype project is created in microservice-reference/target/generated-sources/archetype&lt;/p&gt;

&lt;h4 id=&quot;copy-the-created-archetype-to-the-microservice-archetype-project&quot;&gt;Copy the created archetype to the microservice-archetype project&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Copy the archetype project created in earlier step to the folder microservice-archetype&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;summary&quot;&gt;Summary&lt;/h3&gt;

&lt;p&gt;In this article, we talked about the need for an archetype in microservices architecture. Archetype serves a starting point for creating new projects and ensure uniformity across microservices. We looked at an example archetype and got an overview of how to create an archetype.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;best-practices-with-cloud-and-microservices&quot;&gt;Best Practices with Cloud and Microservices&lt;/h3&gt;

&lt;p&gt;This is the first article in a series of six articles on best practices with cloud and microservices:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/12-factor-app-cloud-native-microservices-best-practices&quot; target=&quot;_blank&quot;&gt;1 - The 12 Factor App - Best Practices In Cloud Native Applications and Microservices&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/introduction-to-event-driven-architectures-with-microservices&quot; target=&quot;_blank&quot;&gt;2 - Microservices Architectures - Event Driven Approach&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/software-best-practices-building-a-vertical-slice&quot; target=&quot;_blank&quot;&gt;3 - Why do you build a Vertical Slice?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/messaging-queues-and-asynchronous-communication-in-microservices&quot; target=&quot;_blank&quot;&gt;4 - Microservice Architecture Best Practices - Messaging Queues&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/creating-archetypes-in-microservices-architectures-best-practices&quot; target=&quot;_blank&quot;&gt;5 - Build an Archetype&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/asynchronous-communication-with-queues-in-microservices&quot; target=&quot;_blank&quot;&gt;6 - Asynchronous communication with queues and microservices - A perfect combination?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!--Section: Lesson UI--&gt;
&lt;section class=&quot;text-center&quot;&gt;
    &lt;hr /&gt;
   
    &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;col-lg-4 col-md-6 col-sm-6&quot;&gt;
            &lt;a target=&quot;_blank&quot; href=&quot;/blog/messaging-queues-and-asynchronous-communication-in-microservices&quot; class=&quot;btn  btn-sm&quot; id=&quot;round-button&quot;&gt;
                &lt;i class=&quot;fas fa-arrow-left mr-2&quot;&gt;&lt;/i&gt;Previous Lesson
            &lt;/a&gt;
        &lt;/div&gt;
     
        &lt;div class=&quot;col-lg-4 col-md-6 col-sm-6&quot;&gt;
            &lt;a target=&quot;_blank&quot; href=&quot;/blog/asynchronous-communication-with-queues-in-microservices&quot; class=&quot;btn btn-sm&quot; id=&quot;round-button&quot;&gt;Next Lesson
                &lt;i class=&quot;fas fa-arrow-right ml-2&quot;&gt;&lt;/i&gt;
            &lt;/a&gt;
        &lt;/div&gt;       
    &lt;/div&gt;

&lt;/section&gt;</content><author><name>Girish Godage</name></author><category term="learning" /><summary type="html">In this article, we focus on learning why creating proper archetypes is important for successful microservices architecture.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/img/microservices.png" /></entry><entry><title type="html">Microservice Architecture Best Practices - Messaging Queues</title><link href="http://localhost:4000/blog/messaging-queues-and-asynchronous-communication-in-microservices" rel="alternate" type="text/html" title="Microservice Architecture Best Practices - Messaging Queues" /><published>2019-10-19T20:17:00+00:00</published><updated>2019-10-19T20:17:00+00:00</updated><id>http://localhost:4000/blog/Microservices21</id><content type="html" xml:base="http://localhost:4000/blog/messaging-queues-and-asynchronous-communication-in-microservices">&lt;p&gt;In this article, we discuss why queues are needed, and how they form the cornerstone of asynchronous communication in microservices architectures.&lt;/p&gt;

&lt;h1 id=&quot;what-you-will-learn&quot;&gt;What you will learn&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;What is a Queue?&lt;/li&gt;
  &lt;li&gt;What is asynchronous communication or asynchronous messaging?&lt;/li&gt;
  &lt;li&gt;What are the advantages of using Queues in microservices architectures?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;why-asynchronous-messaging&quot;&gt;Why Asynchronous Messaging?&lt;/h3&gt;

&lt;p&gt;Why is asynchronous messaging important?&lt;/p&gt;

&lt;p&gt;Consider the simple example of an ordering service:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Capture-050-02.png&quot; alt=&quot;image info&quot; /&gt;&lt;/p&gt;

&lt;p&gt;A customer places an order through the OrderService. Let’s say following steps are involved:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;It needs to send a request to the StockService&lt;/li&gt;
  &lt;li&gt;Send communication to the user through the EmailService and SMSService&lt;/li&gt;
  &lt;li&gt;Call the PackageService to start delivery&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;option-1--single-component-for-all-processing&quot;&gt;Option 1 : Single Component for all processing&lt;/h3&gt;

&lt;p&gt;One way to design this application would be to have a single component that accomplishes all this functionality. For example, write a Java class which accepts the order, and does the entire processing itself.&lt;/p&gt;

&lt;h3 id=&quot;option-2--introducing-asynchronous-messaging-using-queues&quot;&gt;Option 2 : Introducing Asynchronous Messaging using Queues&lt;/h3&gt;

&lt;p&gt;The other option is to have a queue in-between the receiving OrderService component, and the rest of the components. When the OrderService receives an order, it places the request on the Queue. The rest of the components are independent services, listening on the Queue.&lt;/p&gt;

&lt;p&gt;As soon as an order is placed on the queue:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;The StockService processes the order and updates the database&lt;/li&gt;
  &lt;li&gt;The EmailService sends out an email to the customer&lt;/li&gt;
  &lt;li&gt;The SMSService sends out an SMS to the user&lt;/li&gt;
  &lt;li&gt;The PackageService does the required package processing on the item&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;single-component-v-queue&quot;&gt;Single Component v Queue&lt;/h3&gt;

&lt;p&gt;If your business goal is to support a few hundreds or thousands of users, then a simple architecture would be a good choice. The first architecture might be all you need.&lt;/p&gt;

&lt;p&gt;However, when we talk of a large scale e-commerce web application such as Amazon.com, that receives millions of orders in a short time, you need a lot of flexibility. That’s when you go for the second approach, of bringing a queue in.&lt;/p&gt;

&lt;h3 id=&quot;advantages-of-using-a-messaging-queue&quot;&gt;Advantages of Using A Messaging Queue&lt;/h3&gt;

&lt;p&gt;Let’s look at the advantages of using asynchronous communication based on a messaging queue.&lt;/p&gt;

&lt;h4 id=&quot;a-queue-improves-reliability&quot;&gt;A Queue Improves Reliability&lt;/h4&gt;

&lt;p&gt;Let’s say the SMSService is down for a short time.&lt;/p&gt;

&lt;p&gt;In Option 1, since the OrderService directly invokes the SMSService on receiving an order, an SMS cannot be sent out. That might mean canceling the order, as all steps are part of a single transaction. Failure of one of the components would lead to cancellation of the customer request, with a need for him to re-initiate the order - at a later point in time.&lt;/p&gt;

&lt;p&gt;However in the second approach, called &lt;strong&gt;asynchronous&lt;/strong&gt; communication, the order request is placed on the queue. When the SMSService comes back up, it will find the order event and process it. It can then send out the SMS messages for all its pending requests.&lt;/p&gt;

&lt;h4 id=&quot;a-queue-provides-scalability&quot;&gt;A Queue Provides Scalability&lt;/h4&gt;

&lt;p&gt;Suppose on a given day, there is a need to send out 100,000 SMS messages. An option with having asynchronous communication is that you can increase the number of instances of the SMSService. This flexibility in number of instances of the components, improves system scalability.&lt;/p&gt;

&lt;h4 id=&quot;a-queue-improves-testability&quot;&gt;A Queue Improves Testability&lt;/h4&gt;

&lt;p&gt;Each of the components/services are loosely tied, and have independent requirements. It is thus much easier to test each one of them, preferably in isolation.&lt;/p&gt;

&lt;h4 id=&quot;a-queue-improves-maintainability&quot;&gt;A Queue Improves Maintainability&lt;/h4&gt;

&lt;p&gt;A queue also improves system maintainability, as the application is divided into smaller services.&lt;/p&gt;

&lt;h4 id=&quot;a-queue-improves-flexibility&quot;&gt;A Queue Improves Flexibility&lt;/h4&gt;

&lt;p&gt;Not only increase instances of existing services, a queue makes the system flexible to add more services in future. All that you need to do is add a new service listen to events on the queue and consuming them. The new service could be plugged in, with a minimum of down time.&lt;/p&gt;

&lt;h4 id=&quot;popular-message-queues&quot;&gt;Popular Message Queues&lt;/h4&gt;

&lt;p&gt;An extremely popular message queue framework is RabbitMQ.&lt;/p&gt;

&lt;p&gt;Different frameworks use different communication protocols, but the concept underlying all of them is the same. At the core, a queue separates the component that generates the event, from the services that consume the event.&lt;/p&gt;

&lt;p&gt;In general, if you need a system that addresses a very large user base, whose users submit a large number of requests to be processed,  go for queue-based systems.&lt;/p&gt;

&lt;h3 id=&quot;summary&quot;&gt;Summary&lt;/h3&gt;

&lt;p&gt;In this article, we looked at the fact that there are two types of architectures - synchronous and asynchronous. Synchronous systems have the disadvantage that one component being down, causes loss of service to the entire system. Asynchronous systems solve this problem by introducing an intermediary queue to hold events. An architecture based on asynchronous communication using a queue improves testability, scalability, maintainability and flexibility.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;best-practices-with-cloud-and-microservices&quot;&gt;Best Practices with Cloud and Microservices&lt;/h3&gt;

&lt;p&gt;This is the first article in a series of six articles on best practices with cloud and microservices:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/12-factor-app-cloud-native-microservices-best-practices&quot; target=&quot;_blank&quot;&gt;1 - The 12 Factor App - Best Practices In Cloud Native Applications and Microservices&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/introduction-to-event-driven-architectures-with-microservices&quot; target=&quot;_blank&quot;&gt;2 - Microservices Architectures - Event Driven Approach&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/software-best-practices-building-a-vertical-slice&quot; target=&quot;_blank&quot;&gt;3 - Why do you build a Vertical Slice?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/messaging-queues-and-asynchronous-communication-in-microservices&quot; target=&quot;_blank&quot;&gt;4 - Microservice Architecture Best Practices - Messaging Queues&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/creating-archetypes-in-microservices-architectures-best-practices&quot; target=&quot;_blank&quot;&gt;5 - Build an Archetype&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/asynchronous-communication-with-queues-in-microservices&quot; target=&quot;_blank&quot;&gt;6 - Asynchronous communication with queues and microservices - A perfect combination?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!--Section: Lesson UI--&gt;
&lt;section class=&quot;text-center&quot;&gt;
    &lt;hr /&gt;
   
    &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;col-lg-4 col-md-6 col-sm-6&quot;&gt;
            &lt;a target=&quot;_blank&quot; href=&quot;/blog/software-best-practices-building-a-vertical-slice&quot; class=&quot;btn  btn-sm&quot; id=&quot;round-button&quot;&gt;
                &lt;i class=&quot;fas fa-arrow-left mr-2&quot;&gt;&lt;/i&gt;Previous Lesson
            &lt;/a&gt;
        &lt;/div&gt;
     
        &lt;div class=&quot;col-lg-4 col-md-6 col-sm-6&quot;&gt;
            &lt;a target=&quot;_blank&quot; href=&quot;/blog/creating-archetypes-in-microservices-architectures-best-practices&quot; class=&quot;btn btn-sm&quot; id=&quot;round-button&quot;&gt;Next Lesson
                &lt;i class=&quot;fas fa-arrow-right ml-2&quot;&gt;&lt;/i&gt;
            &lt;/a&gt;
        &lt;/div&gt;       
    &lt;/div&gt;

&lt;/section&gt;</content><author><name>Girish Godage</name></author><category term="learning" /><summary type="html">In this article, we discuss why queues are needed, and how they form the cornerstone of asynchronous communication in microservices architectures.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/img/microservices.png" /></entry><entry><title type="html">Microservice Best Practice - Why do you build a Vertical Slice?</title><link href="http://localhost:4000/blog/software-best-practices-building-a-vertical-slice" rel="alternate" type="text/html" title="Microservice Best Practice - Why do you build a Vertical Slice?" /><published>2019-10-19T20:17:00+00:00</published><updated>2019-10-19T20:17:00+00:00</updated><id>http://localhost:4000/blog/Microservices20</id><content type="html" xml:base="http://localhost:4000/blog/software-best-practices-building-a-vertical-slice">&lt;p&gt;In this article, we look at what is a vertical slice, and why we build it. We also discuss the best practices involved in building vertical slices.&lt;/p&gt;

&lt;h3 id=&quot;what-you-will-learn&quot;&gt;What you will learn&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;What is an vertical slice?&lt;/li&gt;
  &lt;li&gt;When do you build a vertical slice?&lt;/li&gt;
  &lt;li&gt;What are the advantages in building a vertical slice?&lt;/li&gt;
  &lt;li&gt;What are the best practices in building a vertical slice?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;need-for-a-vertical-slice&quot;&gt;Need For A Vertical Slice&lt;/h3&gt;

&lt;p&gt;Let’s say you want to start off writing a new microservice, or developing any new application. There are several technical risks that need to be addressed , such as deciding what framework to use, identifying the layers of the architecture, figuring out communication with other systems, and so on.&lt;/p&gt;

&lt;p&gt;You want to make sure you have great unit tests in place, and also have a good continuous integration and deployment system to process the builds.&lt;/p&gt;

&lt;p&gt;How do we address these challenges?&lt;/p&gt;

&lt;h3 id=&quot;what-is-a-vertical-slice&quot;&gt;What Is A Vertical Slice?&lt;/h3&gt;

&lt;p&gt;A vertical slice involves selecting one or more of the complex or risky use cases of the systems, and implementing them first.&lt;/p&gt;

&lt;p&gt;Typically, this involves addressing all the risks listed above - selecting the right framework, organizing into layers, handling communication properly, having great tests in place, and following a CI/CD process.&lt;/p&gt;

&lt;p&gt;You will also deploy and test it to make sure all requirements are met.&lt;/p&gt;

&lt;h3 id=&quot;benefits-of-a-vertical-slice&quot;&gt;Benefits Of A Vertical Slice&lt;/h3&gt;

&lt;p&gt;A vertical slice will help you identify and solve technology risk faster. Once a vertical slice is built well, adhering to coding and other standards, it could also act as a reference point for other developers in your team.&lt;/p&gt;

&lt;h3 id=&quot;best-practices&quot;&gt;Best Practices&lt;/h3&gt;

&lt;p&gt;Lets quickly look at a few best practices around building vertical slices:&lt;/p&gt;

&lt;h4 id=&quot;ensure-static-analysis&quot;&gt;Ensure Static Analysis&lt;/h4&gt;

&lt;p&gt;Make sure that a tool to perform static analysis of your code is in place during the development of the vertical slice. Also make sure development adheres to all relevant best practices.&lt;/p&gt;

&lt;h4 id=&quot;ensure-continuous-integration&quot;&gt;Ensure Continuous Integration&lt;/h4&gt;

&lt;p&gt;It is very important you have a continuous integration process in place, to take the vertical slice build through development, QA, staging and deployment.&lt;/p&gt;

&lt;h4 id=&quot;address-technical-training-issues&quot;&gt;Address Technical Training Issues&lt;/h4&gt;

&lt;p&gt;If the vertical slice is well implemented, it acts as a good reference point. This means that the development team can be trained using the vertical slice as a case study.&lt;/p&gt;

&lt;h3 id=&quot;challenges&quot;&gt;Challenges&lt;/h3&gt;

&lt;p&gt;It is very important that care be shown in selecting the use case for your vertical slice. Make sure that you choose a sufficiently complex use case, because you need to explore how the various technical risks will be addressed.&lt;/p&gt;

&lt;h3 id=&quot;summary&quot;&gt;Summary&lt;/h3&gt;

&lt;p&gt;In this article, we had a look at what are the technical risks involved in starting application development. We then saw how creating a vertical slice, using a complex use case, helps in exploring solutions to these risks, and acts as a reference point for the development team. We explored the best practices for creating a vertical slice, and looked at the challenges involved.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;best-practices-with-cloud-and-microservices&quot;&gt;Best Practices with Cloud and Microservices&lt;/h3&gt;

&lt;p&gt;This is the first article in a series of six articles on best practices with cloud and microservices:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/12-factor-app-cloud-native-microservices-best-practices&quot; target=&quot;_blank&quot;&gt;1 - The 12 Factor App - Best Practices In Cloud Native Applications and Microservices&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/introduction-to-event-driven-architectures-with-microservices&quot; target=&quot;_blank&quot;&gt;2 - Microservices Architectures - Event Driven Approach&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/software-best-practices-building-a-vertical-slice&quot; target=&quot;_blank&quot;&gt;3 - Why do you build a Vertical Slice?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/messaging-queues-and-asynchronous-communication-in-microservices&quot; target=&quot;_blank&quot;&gt;4 - Microservice Architecture Best Practices - Messaging Queues&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/creating-archetypes-in-microservices-architectures-best-practices&quot; target=&quot;_blank&quot;&gt;5 - Build an Archetype&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/asynchronous-communication-with-queues-in-microservices&quot; target=&quot;_blank&quot;&gt;6 - Asynchronous communication with queues and microservices - A perfect combination?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!--Section: Lesson UI--&gt;
&lt;section class=&quot;text-center&quot;&gt;
    &lt;hr /&gt;
   
    &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;col-lg-4 col-md-6 col-sm-6&quot;&gt;
            &lt;a target=&quot;_blank&quot; href=&quot;/blog/introduction-to-event-driven-architectures-with-microservices&quot; class=&quot;btn  btn-sm&quot; id=&quot;round-button&quot;&gt;
                &lt;i class=&quot;fas fa-arrow-left mr-2&quot;&gt;&lt;/i&gt;Previous Lesson
            &lt;/a&gt;
        &lt;/div&gt;
     
        &lt;div class=&quot;col-lg-4 col-md-6 col-sm-6&quot;&gt;
            &lt;a target=&quot;_blank&quot; href=&quot;/blog/messaging-queues-and-asynchronous-communication-in-microservices&quot; class=&quot;btn btn-sm&quot; id=&quot;round-button&quot;&gt;Next Lesson
                &lt;i class=&quot;fas fa-arrow-right ml-2&quot;&gt;&lt;/i&gt;
            &lt;/a&gt;
        &lt;/div&gt;       
    &lt;/div&gt;

&lt;/section&gt;</content><author><name>Girish Godage</name></author><category term="learning" /><summary type="html">In this article, we look at what is a vertical slice, and why we build it. We also discuss the best practices involved in building vertical slices.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/img/microservices.png" /></entry><entry><title type="html">Microservices Architectures - Event Driven Approach</title><link href="http://localhost:4000/blog/introduction-to-event-driven-architectures-with-microservices" rel="alternate" type="text/html" title="Microservices Architectures - Event Driven Approach" /><published>2019-10-19T20:17:00+00:00</published><updated>2019-10-19T20:17:00+00:00</updated><id>http://localhost:4000/blog/Microservices19</id><content type="html" xml:base="http://localhost:4000/blog/introduction-to-event-driven-architectures-with-microservices">&lt;h3 id=&quot;the-need-for-event-driven-architecture&quot;&gt;The Need For Event Driven Architecture&lt;/h3&gt;

&lt;p&gt;Microservices architectures have multiple small-sized microservices talking to each other. Here is one such architecture:
&lt;img src=&quot;/images/Capture-060-02.png&quot; alt=&quot;image info&quot; /&gt;&lt;/p&gt;

&lt;p&gt;There are a set of common components - technical as well as infrastructure. Examples of technical components are Security and Logging components. Examples of infrastructure components include Naming Server, API Gateway and Centralized Logging.&lt;/p&gt;

&lt;p&gt;When implementing microservices, you would want to make them as event driven as possible. Why? Let’s take an example&lt;/p&gt;

&lt;h3 id=&quot;take-a-use-case&quot;&gt;Take A Use Case&lt;/h3&gt;

&lt;p&gt;Consider the use case of an online shopping application. Whenever there is an order, it is received by the order service. There are several actions that need to be carried out in order service:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Update the stock&lt;/li&gt;
  &lt;li&gt;Send out email and SMS&lt;/li&gt;
  &lt;li&gt;Notify the packaging team.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;monolithic-approach&quot;&gt;Monolithic Approach&lt;/h4&gt;

&lt;p&gt;An initial approach could be to have a single monolith application to take care of all the functionality.&lt;/p&gt;

&lt;h4 id=&quot;microservices-approach&quot;&gt;Microservices Approach&lt;/h4&gt;

&lt;p&gt;Alternatively, these are fairly independent activities, and the entire application can be structured to have microservices for them, in a straightforward manner.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Capture-060-03.png&quot; alt=&quot;image info&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In this approach, you create an order event for the request coming in, and place it in the Queue. The rest of the individual services listen in to the queue for order events, and do the processing subsequently.&lt;/p&gt;

&lt;h4 id=&quot;how-to-choose&quot;&gt;How to choose?&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;How do we make the decision which of the two application architectures to choose?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The nature of your application decides this.&lt;/p&gt;

&lt;p&gt;If your system does not have a very high load at any given time, and also does not have any pressing scalability requirements, then you might want go with a monolith approach.&lt;/p&gt;

&lt;p&gt;However, when your system is a large , handling millions of requests every day, and also has very stringent scalability requirements, you might be better off with the microservices approach.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;An event driven architecture would be the one best suited to your needs.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;advantages-of-event-driven-architectures&quot;&gt;Advantages Of Event Driven Architectures&lt;/h3&gt;

&lt;h4 id=&quot;improved-flexibility-and-maintainability&quot;&gt;Improved Flexibility And Maintainability&lt;/h4&gt;

&lt;p&gt;One of the most important needs of an application is maintainability. Ease of maintainability comes with proper &lt;strong&gt;separation of concerns&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;In our example above, the OrderService is only responsible for collecting the order and placing it in the queue. It does not worry about how it is going to be processed, who is going to process it, and so on.&lt;/p&gt;

&lt;p&gt;Similarly,  the StockService is only responsible for updating the stock, and the same with the other microservices.&lt;/p&gt;

&lt;p&gt;If there is a need for an additional processing step on an order, you write a new microservice to listen on the queue, and easily integrate it into the system.&lt;/p&gt;

&lt;p&gt;Such an architecture is clearly extensible, and also easily maintainable, due to separation of concerns.&lt;/p&gt;

&lt;h4 id=&quot;high-scalability&quot;&gt;High Scalability&lt;/h4&gt;

&lt;p&gt;Let’s consider an example : One fine day, a large volume of emails need to be sent out.&lt;/p&gt;

&lt;p&gt;In that case, you have the freedom to create a large number of instances of the EmailService, to handle additional load.&lt;/p&gt;

&lt;p&gt;A similar thing can be spoken about the other microservices in the mix, depending on the need of the hour.&lt;/p&gt;

&lt;p&gt;This is a clear advantage of this architecture, over using a single component to handle all the functionality.&lt;/p&gt;

&lt;h4 id=&quot;improved-availability&quot;&gt;Improved Availability&lt;/h4&gt;

&lt;p&gt;Let’s say one of the services listening for order events from the queue, such as the PackageService, goes down.&lt;/p&gt;

&lt;p&gt;In the first architecture approach of using a monolithic approach, any one functionality going down would mean the application cannot process orders any more.&lt;/p&gt;

&lt;p&gt;In case of an event driven architecture, the PackageService going down would not prevent the OrderService from putting the order event into the Queue. The OrderService can notify the user of successful request receipt.&lt;/p&gt;

&lt;p&gt;A notification request would then be sent to the troubleshooting team about the PackageServer going down, and while it is being restored, the order event remains in the Queue. It can be processed by all the other services during this time, and when PAckageService comes back up, it can process the event as if nothing untoward has happened.&lt;/p&gt;

&lt;h4 id=&quot;good-reliability&quot;&gt;Good Reliability&lt;/h4&gt;

&lt;p&gt;Event driven architectures ensure a good standard of reliability for the system as a whole. However, the individual microservices can function with different levels of reliability. For example the StockService normally needs to ensure a high level of reliability, the EmailService and SMSService a medium level of reliability, and the PackageService - between low and medium levels of reliability.&lt;/p&gt;

&lt;h4 id=&quot;good-performance-and-responsiveness&quot;&gt;Good Performance and Responsiveness&lt;/h4&gt;

&lt;p&gt;Note that in our example event driven architecture, all that the OrderService does is receive the order and place it on the queue, before acknowledging the user. The user does not need to wait till all the steps are performed on an order. This has high high responsiveness, and is seen by the user as high performance.&lt;/p&gt;

&lt;h3 id=&quot;summary&quot;&gt;Summary&lt;/h3&gt;

&lt;p&gt;In this article, we had a look at event driven architectures. We saw that event driven architecture is ideal for implementing applications with high load, and strict scalability needs.&lt;/p&gt;

&lt;p&gt;We saw an example of an online shopping application that employs such an architecture. The advantages of using such an architecture include improved flexibility and maintainability, high scalability, imrpoved availability, good reliability and good performance.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;best-practices-with-cloud-and-microservices&quot;&gt;Best Practices with Cloud and Microservices&lt;/h3&gt;

&lt;p&gt;This is the first article in a series of six articles on best practices with cloud and microservices:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/12-factor-app-cloud-native-microservices-best-practices&quot; target=&quot;_blank&quot;&gt;1 - The 12 Factor App - Best Practices In Cloud Native Applications and Microservices&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/introduction-to-event-driven-architectures-with-microservices&quot; target=&quot;_blank&quot;&gt;2 - Microservices Architectures - Event Driven Approach&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/software-best-practices-building-a-vertical-slice&quot; target=&quot;_blank&quot;&gt;3 - Why do you build a Vertical Slice?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/messaging-queues-and-asynchronous-communication-in-microservices&quot; target=&quot;_blank&quot;&gt;4 - Microservice Architecture Best Practices - Messaging Queues&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/creating-archetypes-in-microservices-architectures-best-practices&quot; target=&quot;_blank&quot;&gt;5 - Build an Archetype&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/asynchronous-communication-with-queues-in-microservices&quot; target=&quot;_blank&quot;&gt;6 - Asynchronous communication with queues and microservices - A perfect combination?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!--Section: Lesson UI--&gt;
&lt;section class=&quot;text-center&quot;&gt;
    &lt;hr /&gt;
   
    &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;col-lg-4 col-md-6 col-sm-6&quot;&gt;
            &lt;a target=&quot;_blank&quot; href=&quot;/blog/12-factor-app-cloud-native-microservices-best-practices&quot; class=&quot;btn  btn-sm&quot; id=&quot;round-button&quot;&gt;
                &lt;i class=&quot;fas fa-arrow-left mr-2&quot;&gt;&lt;/i&gt;Previous Lesson
            &lt;/a&gt;
        &lt;/div&gt;
     
        &lt;div class=&quot;col-lg-4 col-md-6 col-sm-6&quot;&gt;
            &lt;a target=&quot;_blank&quot; href=&quot;/blog/software-best-practices-building-a-vertical-slice&quot; class=&quot;btn btn-sm&quot; id=&quot;round-button&quot;&gt;Next Lesson
                &lt;i class=&quot;fas fa-arrow-right ml-2&quot;&gt;&lt;/i&gt;
            &lt;/a&gt;
        &lt;/div&gt;       
    &lt;/div&gt;

&lt;/section&gt;</content><author><name>Girish Godage</name></author><category term="learning" /><summary type="html">The Need For Event Driven Architecture</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/img/microservices.png" /></entry><entry><title type="html">The 12 Factor App - Best Practices In Cloud Native Applications and Microservices</title><link href="http://localhost:4000/blog/12-factor-app-cloud-native-microservices-best-practices" rel="alternate" type="text/html" title="The 12 Factor App - Best Practices In Cloud Native Applications and Microservices" /><published>2019-10-19T20:17:00+00:00</published><updated>2019-10-19T20:17:00+00:00</updated><id>http://localhost:4000/blog/Microservices18</id><content type="html" xml:base="http://localhost:4000/blog/12-factor-app-cloud-native-microservices-best-practices">&lt;p&gt;In order that an application be deployed in the cloud and enjoy features such as auto scaling, it first needs to be cloud native. In this article, we have a close look at the best practices for cloud native applications, popularly known as The 12 Factor App.&lt;/p&gt;

&lt;h2 id=&quot;the-12-factor-app&quot;&gt;The 12 Factor App&lt;/h2&gt;

&lt;p&gt;12 Factor App is a set of best practices that guide you to build a great cloud native application. These were framed by Heroku, based on their experiences with building cloud native applications.&lt;/p&gt;

&lt;h3 id=&quot;1codebase---one-codebase-tracked-in-revision-control-many-deploys&quot;&gt;1.Codebase - One codebase tracked in revision control, many deploys&lt;/h3&gt;

&lt;p&gt;You have the codebase in a version control system, and you extract and build it, then deploy it many times.&lt;/p&gt;

&lt;h3 id=&quot;2dependencies---explicitly-declare-and-isolate-dependencies&quot;&gt;2.Dependencies - Explicitly declare and isolate dependencies&lt;/h3&gt;

&lt;p&gt;Whenever you build a software application, say in Java, you need a number of dependencies such as frameworks. You may need to manage the versions of the libraries you need to use. Explicitly declare and isolate such dependencies.&lt;/p&gt;

&lt;h3 id=&quot;3config---store-config-in-the-environment&quot;&gt;3.Config - Store config in the environment&lt;/h3&gt;

&lt;p&gt;There are a variety of environments where an application could execute, such as development, QA, staging and production. Applications have different configuration in each of the environments. It is recommended to seperate the configuration and store it within the environment itself.&lt;/p&gt;

&lt;p&gt;Another option is to store the configuration information in a centralized repository.&lt;/p&gt;

&lt;p&gt;An good example is Spring Cloud Config Server. The configuration is stored in the config server, which can then be mapped to the environment.&lt;/p&gt;

&lt;h3 id=&quot;4backing-services---treat-backing-services-as-attached-resources&quot;&gt;4.Backing services - Treat backing services as attached resources&lt;/h3&gt;

&lt;p&gt;Backing services refers to the other systems that an application needs to talk to, and this also includes the databases. All such services need to be considered as attached resources.&lt;/p&gt;

&lt;p&gt;All of these need to be configurable, and it should be easy to switch from one backing service to another. This switch should be possible with just a switch in configuration.&lt;/p&gt;

&lt;h3 id=&quot;5build-release-run---strictly-separate-build-and-run-stages&quot;&gt;5.Build, release, run - Strictly separate build and run stages&lt;/h3&gt;

&lt;p&gt;The build, release and run stages need to be strictly separated.&lt;/p&gt;

&lt;p&gt;You need to be able to build a deployable component, such as a JAR, WAR or an EAR, that is independent of the environment. There should not be any change in this component as the deployment environment changes.&lt;/p&gt;

&lt;p&gt;A release is a phase where we take this reusable component, and combine it with a specific configuration for a target environment.&lt;/p&gt;

&lt;p&gt;The next phase is to take the released entity, create a container out of it, and run it in the environment.&lt;/p&gt;

&lt;h3 id=&quot;6processes---execute-the-app-as-one-or-more-stateless-processes&quot;&gt;6.Processes - Execute the app as one or more stateless processes&lt;/h3&gt;

&lt;p&gt;Ideally an application should be stateless.&lt;/p&gt;

&lt;p&gt;But, in case you have state - where you store the state of an application determines how flexible it is.&lt;/p&gt;

&lt;p&gt;If you store state in a central data store such as redis, it makes the application very flexible.&lt;/p&gt;

&lt;p&gt;You no longer need sticky sessions. You can have any instance of an app, answer any request.&lt;/p&gt;

&lt;h3 id=&quot;7port-binding---export-services-via-port-binding&quot;&gt;7.Port binding - Export services via port binding&lt;/h3&gt;

&lt;p&gt;You should be able to deploy applications as services, by tying them with ports.&lt;/p&gt;

&lt;h3 id=&quot;8concurrency---scale-out-via-the-process-model&quot;&gt;8.Concurrency - Scale out via the process model&lt;/h3&gt;

&lt;p&gt;There are two kinds of scaling that can be applied to an application - horizontal and vertical. Vertical scaling refers to increasing the hardware infrastructure, such as increasing the CPU processing power, or increasing the amount of physical memory available to the application. Clearly, there are limits to such an approach.&lt;/p&gt;

&lt;p&gt;Horizontal scaling refers to the possibility of dynamically increasing or decreasing the number of instances of an application, depending on the system needs.&lt;/p&gt;

&lt;p&gt;Your applications should be built to be able to dynamically adapt to changing number of instances of various services.&lt;/p&gt;

&lt;h3 id=&quot;9disposability---maximize-robustness-with-fast-startup-and-graceful-shutdown&quot;&gt;9.Disposability - Maximize robustness with fast startup and graceful shutdown&lt;/h3&gt;

&lt;p&gt;If one of the instances of the application is causing errors, or is slow in responding to requests, or is not responding at all, it should be possible to gracefully shut the instance down.&lt;/p&gt;

&lt;p&gt;In addition, the other applications in the system should not be affected by this change in the environment.&lt;/p&gt;

&lt;p&gt;You should be able to bring in new instances as they are needed, and take down instances when required. This property is known as disposability, and is a measure of the system’s robustness.&lt;/p&gt;

&lt;h3 id=&quot;10development--production-parity&quot;&gt;10.Development / Production Parity&lt;/h3&gt;

&lt;p&gt;There is a strong need to keep the development, QA, staging and production stages of a deployment pipeline, as similar as possible. The similarities should apply to the processes you follow, the technologies you make use of, and the infrastructure you employ.&lt;/p&gt;

&lt;p&gt;If you have this parity among these stages, then most of the problems that could arise with the application, would appear in the earlier stages. Not many surprises would be in store for you at production.&lt;/p&gt;

&lt;h3 id=&quot;11logs---treat-logs-as-event-streams&quot;&gt;11.Logs - Treat logs as event streams&lt;/h3&gt;

&lt;p&gt;Visibility is one of the most important requirements of a microservices architecture.&lt;/p&gt;

&lt;p&gt;By treating each log message entered into a centralized logging system as an event, you get a sequence of actions that are performed on a request when it enters the system, right up to when it is completed or abandoned.&lt;/p&gt;

&lt;p&gt;All one needs to do in order to debug a problem, is to go to the central dashboard and search for it.&lt;/p&gt;

&lt;h3 id=&quot;12admin-processes---run-adminmanagement-tasks-as-one-off-processes&quot;&gt;12.Admin processes - Run admin/management tasks as one-off processes&lt;/h3&gt;

&lt;p&gt;There are a number of one-off process that you need to run - batch programs, database migrations, scripts.&lt;/p&gt;

&lt;p&gt;Treat one-off processes the same way as long running processes.&lt;/p&gt;

&lt;p&gt;Have the same standards - have code base in version control, follow standard deployment processes and use the same environments&lt;/p&gt;

&lt;h3 id=&quot;summary&quot;&gt;Summary&lt;/h3&gt;

&lt;p&gt;In this article, we looked at the best practices for cloud native applications, called the 12 Factor App.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;best-practices-with-cloud-and-microservices&quot;&gt;Best Practices with Cloud and Microservices&lt;/h3&gt;

&lt;p&gt;This is the first article in a series of six articles on best practices with cloud and microservices:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/12-factor-app-cloud-native-microservices-best-practices&quot; target=&quot;_blank&quot;&gt;1 - The 12 Factor App - Best Practices In Cloud Native Applications and Microservices&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/introduction-to-event-driven-architectures-with-microservices&quot; target=&quot;_blank&quot;&gt;2 - Microservices Architectures - Event Driven Approach&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/software-best-practices-building-a-vertical-slice&quot; target=&quot;_blank&quot;&gt;3 - Why do you build a Vertical Slice?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/messaging-queues-and-asynchronous-communication-in-microservices&quot; target=&quot;_blank&quot;&gt;4 - Microservice Architecture Best Practices - Messaging Queues&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/creating-archetypes-in-microservices-architectures-best-practices&quot; target=&quot;_blank&quot;&gt;5 - Build an Archetype&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/asynchronous-communication-with-queues-in-microservices&quot; target=&quot;_blank&quot;&gt;6 - Asynchronous communication with queues and microservices - A perfect combination?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!--Section: Lesson UI--&gt;
&lt;section class=&quot;text-center&quot;&gt;
    &lt;hr /&gt;
   
    &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;col-lg-4 col-md-6 col-sm-6&quot;&gt;
            &lt;a target=&quot;_blank&quot; href=&quot;/blog/12-factor-app-cloud-native-microservices-best-practices&quot; class=&quot;btn  btn-sm&quot; id=&quot;round-button&quot;&gt;
                &lt;i class=&quot;fas fa-arrow-left mr-2&quot;&gt;&lt;/i&gt;Previous Lesson
            &lt;/a&gt;
        &lt;/div&gt;
     
        &lt;div class=&quot;col-lg-4 col-md-6 col-sm-6&quot;&gt;
            &lt;a target=&quot;_blank&quot; href=&quot;/blog/introduction-to-event-driven-architectures-with-microservices&quot; class=&quot;btn btn-sm&quot; id=&quot;round-button&quot;&gt;Next Lesson
                &lt;i class=&quot;fas fa-arrow-right ml-2&quot;&gt;&lt;/i&gt;
            &lt;/a&gt;
        &lt;/div&gt;       
    &lt;/div&gt;

&lt;/section&gt;</content><author><name>Girish Godage</name></author><category term="learning" /><summary type="html">In order that an application be deployed in the cloud and enjoy features such as auto scaling, it first needs to be cloud native. In this article, we have a close look at the best practices for cloud native applications, popularly known as The 12 Factor App.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/img/microservices.png" /></entry><entry><title type="html">Microservices Architectures - What is Fault Tolerance?</title><link href="http://localhost:4000/blog/fault-tolerance-in-microservices" rel="alternate" type="text/html" title="Microservices Architectures - What is Fault Tolerance?" /><published>2019-10-19T20:17:00+00:00</published><updated>2019-10-19T20:17:00+00:00</updated><id>http://localhost:4000/blog/Microservices17</id><content type="html" xml:base="http://localhost:4000/blog/fault-tolerance-in-microservices">&lt;p&gt;In this article, we discuss an important property of microservices, called fault tolerance.&lt;/p&gt;

&lt;h2 id=&quot;you-will-learn&quot;&gt;You will learn&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;What is Fault Tolerance?&lt;/li&gt;
  &lt;li&gt;Why is fault tolerance important in microservices architecture?&lt;/li&gt;
  &lt;li&gt;How do you achieve fault tolerance?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;what-is-fault-tolerance&quot;&gt;What Is Fault Tolerance?&lt;/h3&gt;

&lt;p&gt;Microservices need to be extremely reliable.&lt;/p&gt;

&lt;p&gt;When we build a microservices architecture, there are a large number of small microservices, and they all need to communicate with one another.&lt;/p&gt;

&lt;p&gt;Lets consider the following example:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Capture-053-02.png&quot; alt=&quot;image info&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Let’s say Microservice5 is down at some point of time.&lt;/p&gt;

&lt;p&gt;All the other microservices are directly or indirectly dependent on it, so they all go down as well.&lt;/p&gt;

&lt;p&gt;The solution to this problem is to have a fallback in case of failure of a microservice. This aspect of a microservice is called &lt;strong&gt;fault tolerance&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&quot;implementing-fault-tolerance-with-hystrix&quot;&gt;Implementing Fault Tolerance with Hystrix&lt;/h3&gt;

&lt;p&gt;A popular framework used to implement fault tolerance is Hystrix, a Netflix open source framework. Here is a code example of the same:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
	&lt;span class=&quot;nd&quot;&gt;@GetMapping&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/fault-tolerance-example&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;nd&quot;&gt;@HystrixCommand&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fallbackMethod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;fallbackRetrieveConfguration&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LimitConfiguration&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;retrieveConfiguration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;RuntimeException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Not Available&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LimitConfiguration&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fallbackRetrieveConfiguration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;LimitConfiguration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;999&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; 

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Hystrix enables you to specify the fallback method for each of your service methods. If the method throws an exception, what should be returned to the service consumer?&lt;/p&gt;

&lt;p&gt;Here, if &lt;code class=&quot;highlighter-rouge&quot;&gt;retrieveConfiguration()&lt;/code&gt; fails, then &lt;code class=&quot;highlighter-rouge&quot;&gt;fallbackRetrieveConfiguration&lt;/code&gt; is called, which returns a hardcoded &lt;code class=&quot;highlighter-rouge&quot;&gt;LimitConfiguration&lt;/code&gt; instance:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Capture-053-03.png&quot; alt=&quot;image info&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;hystrix-and-alerts&quot;&gt;Hystrix And Alerts&lt;/h4&gt;

&lt;p&gt;With Hystrix, you can also configure alerts at the back-end. If a service starts failing continuously, you can send alerts to the maintainance team.&lt;/p&gt;

&lt;h3 id=&quot;hystrix-is-not-a-silver-bullet&quot;&gt;Hystrix is not a silver bullet&lt;/h3&gt;

&lt;p&gt;Using Hystrix and fallback methods is appropriate for services that handle non critical information.&lt;/p&gt;

&lt;p&gt;However, it is not a silver bullet.&lt;/p&gt;

&lt;p&gt;Consider for instance, a service that returns the balance of a bank  account. You cannot provide a default hardcoded value back.&lt;/p&gt;

&lt;h3 id=&quot;using-sufficient-redundancy&quot;&gt;Using sufficient redundancy&lt;/h3&gt;

&lt;p&gt;It is important to design critical services in a fail safe manner. It is important to build enough redundancy into the system to ensure that the services do not fail.&lt;/p&gt;

&lt;h3 id=&quot;have-sufficient-testing&quot;&gt;Have sufficient testing&lt;/h3&gt;

&lt;p&gt;It is important to test for failure. Bring a microservice down. See how your system reacts.&lt;/p&gt;

&lt;p&gt;Chaos Monkey is a good example from Netflix.&lt;/p&gt;

&lt;h3 id=&quot;summary&quot;&gt;Summary&lt;/h3&gt;

&lt;p&gt;In this article, we discussed about fault tolerance. We saw how fault tolerance is essential in microservices architecture. We then saw how it can be implemented at the code level using frameworks such as Hystrix.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;cloud-and-microservices-terminology&quot;&gt;Cloud and Microservices Terminology&lt;/h3&gt;

&lt;p&gt;This is the article in a series of six articles on terminology used with cloud and microservices:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/service-discovery-in-microservices&quot; target=&quot;_blank&quot;&gt;1 - Microservices Architectures - What is Service Discovery?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/introduction-to-centralized-configuration-with-spring-cloud-config-server&quot; target=&quot;_blank&quot;&gt;2 - Microservices Architectures - Centralized Configuration and Config Server&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/introduction-to-api-gateways-with-microservices&quot; target=&quot;_blank&quot;&gt;3 - Microservices Architectures - API Gateways&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/introduction-to-centralized-logging-with-microservices&quot; target=&quot;_blank&quot;&gt;4 - Microservices Architectures - Importance of Centralized Logging&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/introduction-to-auto-scaling-or-dynamic-scaling-in-cloud&quot; target=&quot;_blank&quot;&gt;5 - Microservices Architectures - Introduction to Auto Scaling&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/fault-tolerance-in-microservices&quot; target=&quot;_blank&quot;&gt;6 - Microservices Architectures - What is Fault Tolerance?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!--Section: Lesson UI--&gt;
&lt;section class=&quot;text-center&quot;&gt;
    &lt;hr /&gt;
   
    &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;col-lg-4 col-md-6 col-sm-6&quot;&gt;
            &lt;a target=&quot;_blank&quot; href=&quot;/blog/introduction-to-auto-scaling-or-dynamic-scaling-in-cloud&quot; class=&quot;btn  btn-sm&quot; id=&quot;round-button&quot;&gt;
                &lt;i class=&quot;fas fa-arrow-left mr-2&quot;&gt;&lt;/i&gt;Previous Lesson
            &lt;/a&gt;
        &lt;/div&gt;
     
        &lt;div class=&quot;col-lg-4 col-md-6 col-sm-6&quot;&gt;
            &lt;a target=&quot;_blank&quot; href=&quot;/blog/fault-tolerance-in-microservices&quot; class=&quot;btn btn-sm&quot; id=&quot;round-button&quot;&gt;Next Lesson
                &lt;i class=&quot;fas fa-arrow-right ml-2&quot;&gt;&lt;/i&gt;
            &lt;/a&gt;
        &lt;/div&gt;       
    &lt;/div&gt;

&lt;/section&gt;</content><author><name>Girish Godage</name></author><category term="learning" /><summary type="html">In this article, we discuss an important property of microservices, called fault tolerance.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/img/microservices.png" /></entry><entry><title type="html">Microservices Architectures - Introduction to Auto Scaling</title><link href="http://localhost:4000/blog/introduction-to-auto-scaling-or-dynamic-scaling-in-cloud" rel="alternate" type="text/html" title="Microservices Architectures - Introduction to Auto Scaling" /><published>2019-10-19T20:17:00+00:00</published><updated>2019-10-19T20:17:00+00:00</updated><id>http://localhost:4000/blog/Microservices16</id><content type="html" xml:base="http://localhost:4000/blog/introduction-to-auto-scaling-or-dynamic-scaling-in-cloud">&lt;p&gt;In this article, we focus our attention on the Dynamic Scaling or Auto Scaling. Why do we need applications that can auto scale?&lt;/p&gt;

&lt;h2 id=&quot;you-will-learn&quot;&gt;You will learn&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;What is Auto or Dynamic Scaling?&lt;/li&gt;
  &lt;li&gt;Why is Dynamic Scaling important in a microservices context?&lt;/li&gt;
  &lt;li&gt;How can you implement Dynamic Scaling in Cloud?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;load-on-applications-varies&quot;&gt;Load On Applications Varies&lt;/h3&gt;

&lt;p&gt;Load on your applications vary depending on time of the day, the day of the month or the month of the year.&lt;/p&gt;

&lt;p&gt;Take for instance, amazon.com. It has very high loads during Thanks Giving Period, up to 20 times the normal load. However, during the major sports events such as Superbowl or a Football World Cup, the traffic could be considerably lesser - because every body is busy watching the event.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;How can you setup infrastructure for applications to manage varying loads?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;It is quite possible that the infrastructure needed to handle 10x the load, is ten times that needed to handle 1x the load.&lt;/p&gt;

&lt;p&gt;If you have on premise infrastructure, you need a large infrastructure in place to handle peak load.&lt;/p&gt;

&lt;p&gt;During periods with lesser load, a lot of infrastructure would be sitting idle.&lt;/p&gt;

&lt;h3 id=&quot;cloud-to-the-rescue&quot;&gt;Cloud To The Rescue&lt;/h3&gt;

&lt;p&gt;That’s where cloud comes into picture.  With cloud, you can request more resources when the load is high and give them back to the cloud when you have less load.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;This is called Scale Out (create more instances as load increases) and Scale In (reduces instances as load goes down)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;How do you build applications that are cloud enabled - applications that work well in the cloud?&lt;/p&gt;

&lt;p&gt;That’s where a microservices architecture comes into picture.&lt;/p&gt;

&lt;h3 id=&quot;introducing-auto-scaling-example&quot;&gt;Introducing Auto Scaling Example&lt;/h3&gt;

&lt;p&gt;Building your application using microservices enables you to increase the number of microservice instances during high load, and reduce them during less load.&lt;/p&gt;

&lt;p&gt;Consider the following example of a CurrencyConversionService:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Capture-055-02.png&quot; alt=&quot;image info&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Capture-055-03.png&quot; alt=&quot;image info&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The CurrencyConversionService talks to the ForexService. The ForexService is concerned with calculating how many INR can result from 1 USD, or how many INR can result from 1 EUR.&lt;/p&gt;

&lt;p&gt;The CurrencyConversionService takes a bag of currencies and amounts, and produce the total amount in a currency of your choice. For example, it will tell the total worth in INR of 10 EUR and 25 USD.&lt;/p&gt;

&lt;p&gt;The ForexService might also be consumed from a number of other microservices.&lt;/p&gt;

&lt;h4 id=&quot;scaling-infrastructure-to-match-load&quot;&gt;Scaling Infrastructure To Match Load&lt;/h4&gt;

&lt;p&gt;The load on ForexService might be different from the load on CurrencyConversionService. You might need to have different number of instances of CurrencyConversionService and ForexService. For example, there may be two instances of the CurrencyConversionService, and five instances of the ForexService:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Capture-055-04.png&quot; alt=&quot;image info&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Capture-055-05.png&quot; alt=&quot;image info&quot; /&gt;&lt;/p&gt;

&lt;p&gt;At a later point in time, the load on CurrencyConversionService could be low, needing just two instances. On the other hand, a much higher load on ForexService could need 50 instances. The requests coming in from the 2 instances of CurrencyConversionService are distributed across the 50 instances of the ForexService.&lt;/p&gt;

&lt;p&gt;That in essence, is the requirement for auto scaling - dynamically changing number of microservice instances, and evenly distributing the load across them.&lt;/p&gt;

&lt;h3 id=&quot;implementing-auto-scaling&quot;&gt;Implementing Auto Scaling&lt;/h3&gt;

&lt;p&gt;There are a few important concepts involved in implementing auto scaling. The following sections discuss them in some detail.&lt;/p&gt;

&lt;h4 id=&quot;naming-server&quot;&gt;Naming Server&lt;/h4&gt;

&lt;p&gt;Naming servers enables something called &lt;strong&gt;location transparency&lt;/strong&gt;. Every microservice registers with the naming service. Any microservice that needs to talk to another microservice, will ask the naming server for its location.&lt;/p&gt;

&lt;p&gt;Whenever a new instance of CurrencyConversionService or ForexService comes up, it registers with the naming server. 
&lt;img src=&quot;/images/Capture-055-06.png&quot; alt=&quot;image info&quot; /&gt;&lt;/p&gt;

&lt;p&gt;When CurrencyConversionService wants to talk to ForexService, it asks the naming server for available instances.&lt;/p&gt;

&lt;h3 id=&quot;implementing-location-transparency&quot;&gt;Implementing Location Transparency&lt;/h3&gt;

&lt;p&gt;CurrencyConversionService knows that there are five instances of the ForexService.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;How does it distribute the load among all these instances?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;That’s where a load balancer comes into the picture.&lt;/p&gt;

&lt;p&gt;A popular client side load balancing framework is Ribbon.
&lt;img src=&quot;/images/Capture-055-07.png&quot; alt=&quot;image info&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Let’s look at a diagram to understand whats happening:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Capture-055-08.png&quot; alt=&quot;image info&quot; /&gt;&lt;/p&gt;

&lt;p&gt;As soon as any instance of CurrencyConversionService or ForexService comes up, it registers itself with the naming server. If the CCSInstance2 wants to know the URL of ForexService instances, it again talks to the naming server. The naming server responds with a list of all instances of the ForexService - FSInstance1 and FSinstance2, and their corresponding URLs.&lt;/p&gt;

&lt;p&gt;The Ribbon load balancer does a round-robin among the ForexService instances to balance out the load among the instances.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Ribbon offers wide variety of load balancing algorithms to choose from.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;when-to-increase-and-decrease-instances&quot;&gt;When to increase and decrease instances?&lt;/h3&gt;

&lt;p&gt;There is one question we did not really talk about.&lt;/p&gt;

&lt;p&gt;How do we know when to increase or decrease the number of instances of a microservices?&lt;/p&gt;

&lt;p&gt;That is where application monitoring and container (Docker) management (using Kubernetes) comes into the picture.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Capture-055-09.png&quot; alt=&quot;image info&quot; /&gt;&lt;/p&gt;

&lt;p&gt;An application needs to be monitored to find out how much load it has. For this, the application has to expose metrics for us to track the load.&lt;/p&gt;

&lt;p&gt;You can containerize each microservice using Docker and create an image.&lt;/p&gt;

&lt;p&gt;Kubernetes has the capability to manage containers. Kubernetes can configured to auto scale based on the load. Kubernetes can identify the application instances, monitor their loads, and automatically scale up and down.&lt;/p&gt;

&lt;h3 id=&quot;summary&quot;&gt;Summary&lt;/h3&gt;

&lt;p&gt;In this article, we talked about auto scaling. We look at important parts of implementing auto scaling - naming server, load balancer, containers (Docker) and container orchestration (Kubernetes).&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;cloud-and-microservices-terminology&quot;&gt;Cloud and Microservices Terminology&lt;/h3&gt;

&lt;p&gt;This is the article in a series of six articles on terminology used with cloud and microservices:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/service-discovery-in-microservices&quot; target=&quot;_blank&quot;&gt;1 - Microservices Architectures - What is Service Discovery?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/introduction-to-centralized-configuration-with-spring-cloud-config-server&quot; target=&quot;_blank&quot;&gt;2 - Microservices Architectures - Centralized Configuration and Config Server&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/introduction-to-api-gateways-with-microservices&quot; target=&quot;_blank&quot;&gt;3 - Microservices Architectures - API Gateways&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/introduction-to-centralized-logging-with-microservices&quot; target=&quot;_blank&quot;&gt;4 - Microservices Architectures - Importance of Centralized Logging&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/introduction-to-auto-scaling-or-dynamic-scaling-in-cloud&quot; target=&quot;_blank&quot;&gt;5 - Microservices Architectures - Introduction to Auto Scaling&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/fault-tolerance-in-microservices&quot; target=&quot;_blank&quot;&gt;6 - Microservices Architectures - What is Fault Tolerance?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!--Section: Lesson UI--&gt;
&lt;section class=&quot;text-center&quot;&gt;
    &lt;hr /&gt;
   
    &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;col-lg-4 col-md-6 col-sm-6&quot;&gt;
            &lt;a target=&quot;_blank&quot; href=&quot;/blog/introduction-to-centralized-logging-with-microservices&quot; class=&quot;btn  btn-sm&quot; id=&quot;round-button&quot;&gt;
                &lt;i class=&quot;fas fa-arrow-left mr-2&quot;&gt;&lt;/i&gt;Previous Lesson
            &lt;/a&gt;
        &lt;/div&gt;
     
        &lt;div class=&quot;col-lg-4 col-md-6 col-sm-6&quot;&gt;
            &lt;a target=&quot;_blank&quot; href=&quot;/blog/fault-tolerance-in-microservices&quot; class=&quot;btn btn-sm&quot; id=&quot;round-button&quot;&gt;Next Lesson
                &lt;i class=&quot;fas fa-arrow-right ml-2&quot;&gt;&lt;/i&gt;
            &lt;/a&gt;
        &lt;/div&gt;       
    &lt;/div&gt;

&lt;/section&gt;</content><author><name>Girish Godage</name></author><category term="learning" /><summary type="html">In this article, we focus our attention on the Dynamic Scaling or Auto Scaling. Why do we need applications that can auto scale?</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/img/microservices.png" /></entry><entry><title type="html">Microservices Architectures - Importance of Centralized Logging</title><link href="http://localhost:4000/blog/introduction-to-centralized-logging-with-microservices" rel="alternate" type="text/html" title="Microservices Architectures - Importance of Centralized Logging" /><published>2019-10-19T20:17:00+00:00</published><updated>2019-10-19T20:17:00+00:00</updated><id>http://localhost:4000/blog/Microservices15</id><content type="html" xml:base="http://localhost:4000/blog/introduction-to-centralized-logging-with-microservices">&lt;p&gt;In this article, we explore the concept of centralized logging, with respect to microservices.&lt;/p&gt;

&lt;h3 id=&quot;you-will-learn&quot;&gt;You will learn&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;What is centralized logging?&lt;/li&gt;
  &lt;li&gt;Why do we need centralized logging?&lt;/li&gt;
  &lt;li&gt;Why are microservices difficult to debug?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;the-need-for-visibility&quot;&gt;The Need For Visibility&lt;/h3&gt;

&lt;p&gt;In a microservices architecture, there are a number of small microservices talking to each other:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Capture-057-02.png&quot; alt=&quot;image info&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In the above example, let’s assume there is a problem with Microservice5, due to which Microservice1 throws an error.&lt;/p&gt;

&lt;p&gt;How does a developer debug the problem?&lt;/p&gt;

&lt;p&gt;He would like to know the details of what’s happening in every microservice from Microservice1 through Microservice5. From such a trace, it should be possible to identify that something went wrong at Microservice5.&lt;/p&gt;

&lt;p&gt;The more you break things down into smaller microservices, the more visibility you need into what’s going on in the background. Otherwise, a lot of time and effort needs to be spent in debugging problems.&lt;/p&gt;

&lt;p&gt;One of the popular ways to improve visibility is by using &lt;strong&gt;centralized logging&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&quot;centralized-logging-using-log-streams&quot;&gt;Centralized Logging Using Log Streams&lt;/h3&gt;

&lt;p&gt;Using Log Streams is one way to implement centralized logging. The common way to implement it is to stream microservice logs to a common queue. Distributed logging server listens to the queue and acts as log store. It provides search capabilities to search the trace.&lt;/p&gt;

&lt;h3 id=&quot;popular-implementations&quot;&gt;Popular Implementations&lt;/h3&gt;

&lt;p&gt;Some of the popular implementations include&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;the ELK stack (Elastic Search, Logstash and Kibana) for Centralized Logging&lt;/li&gt;
  &lt;li&gt;Zipkin, Open Tracing API And Zaeger for Distributed Tracing&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;summary&quot;&gt;Summary&lt;/h3&gt;

&lt;p&gt;In this article, we had a look at centralized logging. We saw that there is a need for high visibility in microservices architecture. Centralized logging provides visibility for better debugging of problems. Using log streams is one way of implementing centralized logging.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;cloud-and-microservices-terminology&quot;&gt;Cloud and Microservices Terminology&lt;/h3&gt;

&lt;p&gt;This is the article in a series of six articles on terminology used with cloud and microservices:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/service-discovery-in-microservices&quot; target=&quot;_blank&quot;&gt;1 - Microservices Architectures - What is Service Discovery?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/introduction-to-centralized-configuration-with-spring-cloud-config-server&quot; target=&quot;_blank&quot;&gt;2 - Microservices Architectures - Centralized Configuration and Config Server&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/introduction-to-api-gateways-with-microservices&quot; target=&quot;_blank&quot;&gt;3 - Microservices Architectures - API Gateways&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/introduction-to-centralized-logging-with-microservices&quot; target=&quot;_blank&quot;&gt;4 - Microservices Architectures - Importance of Centralized Logging&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/introduction-to-auto-scaling-or-dynamic-scaling-in-cloud&quot; target=&quot;_blank&quot;&gt;5 - Microservices Architectures - Introduction to Auto Scaling&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/fault-tolerance-in-microservices&quot; target=&quot;_blank&quot;&gt;6 - Microservices Architectures - What is Fault Tolerance?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!--Section: Lesson UI--&gt;
&lt;section class=&quot;text-center&quot;&gt;
    &lt;hr /&gt;
   
    &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;col-lg-4 col-md-6 col-sm-6&quot;&gt;
            &lt;a target=&quot;_blank&quot; href=&quot;/blog/introduction-to-api-gateways-with-microservices&quot; class=&quot;btn  btn-sm&quot; id=&quot;round-button&quot;&gt;
                &lt;i class=&quot;fas fa-arrow-left mr-2&quot;&gt;&lt;/i&gt;Previous Lesson
            &lt;/a&gt;
        &lt;/div&gt;
     
        &lt;div class=&quot;col-lg-4 col-md-6 col-sm-6&quot;&gt;
            &lt;a target=&quot;_blank&quot; href=&quot;/blog/introduction-to-auto-scaling-or-dynamic-scaling-in-cloud&quot; class=&quot;btn btn-sm&quot; id=&quot;round-button&quot;&gt;Next Lesson
                &lt;i class=&quot;fas fa-arrow-right ml-2&quot;&gt;&lt;/i&gt;
            &lt;/a&gt;
        &lt;/div&gt;       
    &lt;/div&gt;

&lt;/section&gt;</content><author><name>Girish Godage</name></author><category term="learning" /><summary type="html">In this article, we explore the concept of centralized logging, with respect to microservices.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/img/microservices.png" /></entry><entry><title type="html">Microservices Architectures - Introduction to API Gateway</title><link href="http://localhost:4000/blog/introduction-to-api-gateways-with-microservices" rel="alternate" type="text/html" title="Microservices Architectures - Introduction to API Gateway" /><published>2019-10-19T20:17:00+00:00</published><updated>2019-10-19T20:17:00+00:00</updated><id>http://localhost:4000/blog/Microservices14</id><content type="html" xml:base="http://localhost:4000/blog/introduction-to-api-gateways-with-microservices">&lt;p&gt;In this article, we look at what an API Gateway is, in the context of microservices.&lt;/p&gt;

&lt;h2 id=&quot;you-will-learn&quot;&gt;You will learn&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;What is an API Gateway?&lt;/li&gt;
  &lt;li&gt;Why do we need API Gateways?&lt;/li&gt;
  &lt;li&gt;How does an API Gateway Work?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;handling-cross-cutting-concerns&quot;&gt;Handling Cross Cutting Concerns&lt;/h3&gt;

&lt;p&gt;Whenever we design and develop a large software application, we make use of  a &lt;strong&gt;layered architecture&lt;/strong&gt;. For instance, in a web application, it is quite common to see an architecture similar to the following:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Capture-02-01.png&quot; alt=&quot;image info&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Here, we see that the application is organized into a Web layer, a Business layer, and a Data layer.&lt;/p&gt;

&lt;p&gt;In a layered architecture, there are specific parts that are common to all these different layers. Such parts include:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Logging&lt;/li&gt;
  &lt;li&gt;Security&lt;/li&gt;
  &lt;li&gt;Performance&lt;/li&gt;
  &lt;li&gt;Auditing&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All these features are applicable across layers, hence it makes sense to implement them in a common way.&lt;/p&gt;

&lt;p&gt;Aspect Oriented programming is a well established way of handling these concerns. Use of constructs such as filters and interceptors is common while implementing them.&lt;/p&gt;

&lt;h3 id=&quot;the-need-for-api-gateway&quot;&gt;The Need For API Gateway&lt;/h3&gt;

&lt;p&gt;When we talk about a microservices architecture, we deal with multiple microservices talking to each other:
&lt;img src=&quot;/images/Capture-059-02.png&quot; alt=&quot;image info&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Where do you implement all the features that are common across microservices?&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;authentication&lt;/li&gt;
  &lt;li&gt;logging&lt;/li&gt;
  &lt;li&gt;auditing&lt;/li&gt;
  &lt;li&gt;rate limiting&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;That’s where the API Gateway comes into the picture.&lt;/p&gt;

&lt;h3 id=&quot;how-does-an-api-gateway-work&quot;&gt;How does an API Gateway Work?&lt;/h3&gt;

&lt;p&gt;In microservices, we route all requests - both internal and external - through API Gateways. We can implement all the common features like authentication, logging, auditing, and rate limiting in the API Gateway.&lt;/p&gt;

&lt;p&gt;For example, you may not want Microservice3 to be called more than 10 times by a particular client. You could do that as part of rate limiting in the API gateway.&lt;/p&gt;

&lt;p&gt;You can implement the common features across microservices in the API gateway. A popular API Gateway implementation is Zuul API Gateway.&lt;/p&gt;

&lt;h3 id=&quot;summary&quot;&gt;Summary&lt;/h3&gt;

&lt;p&gt;Just like AOP handles cross cutting concerns in standalone applications, the API gateway manages common features for microservices in an enterprise.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;cloud-and-microservices-terminology&quot;&gt;Cloud and Microservices Terminology&lt;/h3&gt;

&lt;p&gt;This is the article in a series of six articles on terminology used with cloud and microservices:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/service-discovery-in-microservices&quot; target=&quot;_blank&quot;&gt;1 - Microservices Architectures - What is Service Discovery?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/introduction-to-centralized-configuration-with-spring-cloud-config-server&quot; target=&quot;_blank&quot;&gt;2 - Microservices Architectures - Centralized Configuration and Config Server&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/introduction-to-api-gateways-with-microservices&quot; target=&quot;_blank&quot;&gt;3 - Microservices Architectures - API Gateways&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/introduction-to-centralized-logging-with-microservices&quot; target=&quot;_blank&quot;&gt;4 - Microservices Architectures - Importance of Centralized Logging&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/introduction-to-auto-scaling-or-dynamic-scaling-in-cloud&quot; target=&quot;_blank&quot;&gt;5 - Microservices Architectures - Introduction to Auto Scaling&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/fault-tolerance-in-microservices&quot; target=&quot;_blank&quot;&gt;6 - Microservices Architectures - What is Fault Tolerance?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!--Section: Lesson UI--&gt;
&lt;section class=&quot;text-center&quot;&gt;
    &lt;hr /&gt;
   
    &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;col-lg-4 col-md-6 col-sm-6&quot;&gt;
            &lt;a target=&quot;_blank&quot; href=&quot;/blog/introduction-to-centralized-configuration-with-spring-cloud-config-server&quot; class=&quot;btn  btn-sm&quot; id=&quot;round-button&quot;&gt;
                &lt;i class=&quot;fas fa-arrow-left mr-2&quot;&gt;&lt;/i&gt;Previous Lesson
            &lt;/a&gt;
        &lt;/div&gt;
     
        &lt;div class=&quot;col-lg-4 col-md-6 col-sm-6&quot;&gt;
            &lt;a target=&quot;_blank&quot; href=&quot;/blog/introduction-to-centralized-logging-with-microservices&quot; class=&quot;btn btn-sm&quot; id=&quot;round-button&quot;&gt;Next Lesson
                &lt;i class=&quot;fas fa-arrow-right ml-2&quot;&gt;&lt;/i&gt;
            &lt;/a&gt;
        &lt;/div&gt;       
    &lt;/div&gt;

&lt;/section&gt;</content><author><name>Girish Godage</name></author><category term="learning" /><summary type="html">In this article, we look at what an API Gateway is, in the context of microservices.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/img/microservices.png" /></entry></feed>